######################################################################
# DKView.pm
######################################################################

use strict;
use DBI;
use CGAPConfig;
use Cache;
use Paging;
use CGI;

use constant ORACLE_LIST_LIMIT => 500;

use constant BIN_SIZE => 100;
my (%window_value, %high_window_value, %low_window_value);
my (@start, @end, @window_val, @tag_num);
my (@high_start, @high_end, @high_window_val);
my (@low_start, @low_end, @low_window_val);
my (%binned_data);
my (%binned_data_detail);
my (%binned_data_high_detail);
my (%binned_data_low_detail);
my (%data, %del_detect, %amp_detect);
my (%ord2bp, %ord2tag, %ord2num);
my (%amp, %del, %dkmap);
my $WIDTH = 400;
my $DETAIL_WIDTH = 100;
my $WIDTH_HIT = ($WIDTH/BIN_SIZE)/2;
my $HALF_WIDTH = $WIDTH/2 + 1;
my $HIT_POSITION = $WIDTH/2 + 26;
my $SCALE = 20;
my $DETAIL_SCALE = 100;
my $N_VIRTUAL_TAGS = 833644;
my $UCSC_DB = "hg17";
my $DETAIL_SCALAR = 2;
my %ORGANISM_NAME  = (
  "Hs"                 => "Human",
  "Mm"                 => "Mouse"
);

my $BASE;

my $dk_cache = new Cache(CACHE_ROOT, DK_CACHE_PREFIX);
my $dk_query_cache = new Cache(CACHE_QUERY_ROOT, DK_CACHE_PREFIX);
my $CACHE_FAIL = 0;
my (%result);

my @chr_order = ("1", "2", "3", "4", "5", "6", "7", "8", "9",
     "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
     "20", "21", "22", "X", "Y");

######################################################################
sub GetDKLibrary_1 {
  my ($base) = @_;

  my ($db, $sql, $stm);
  $db = DBI->connect("DBI:Oracle:" . DB_INSTANCE, DB_USER, DB_PASS);
  if (not $db or $db->err()) {
    print STDERR "Cannot connect to " . DB_USER . "@" . DB_INSTANCE . "\n";
    exit();
  }
 
  my $output =
    "<table border=\"1\" width=92% cellpadding=2>" .
    "<tr bgcolor=\"#666699\">" .
    "<td width=35%><font color=\"white\"><b>Library Name</b></font></td>" .
    "<td width=14%><font color=\"white\"><b>Tissue</b></font></td>" .
    "<td width=14%><font color=\"white\"><b>Histology</b></font></td>" .
    "<td width=14%><font color=\"white\"><b>Total Tags</b></font></td>" .
    "<td width=14%><font color=\"white\"><b>Mapped Tags</b></font></td>" .
    "<td width=9%><font color=\"white\"><b>DKView</b></font></td>" .
    "</tr>";
 
  $sql = "select NAME, TAGS_PLUS, MAPPED_TAGS_PLUS, THE_TISS, " .
         "THE_HIST, FILE_NAME, DOWNLOAD_MAPPED_CACHE_ID " .
         "from $CGAP_SCHEMA.DK_SAGELIBINFO order by NAME"; 
 
  $stm = $db->prepare($sql);
  if(not $stm) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "prepare call failed\n";
  }
  if(!$stm->execute()) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "execute call failed\n";
  }
  while(my ($NAME, $TAGS_PLUS, $MAPPED_TAGS_PLUS, $THE_TISS, $THE_HIST, 
            $FILE_NAME, $DOWNLOAD_MAPPED_CACHE_ID ) = $stm->fetchrow_array()) {
    $output = $output . 
       "<tr>" .
       "<td width=35% NOWRAP>" .
       "<a href=javascript:spawn(\"/SAGE/SAGEDKLibInfo?LIBNAME=$NAME&ORG=Hs\")>$NAME</a></td>" .
       "<td width=14% NOWRAP>$THE_TISS</td>" .
       "<td width=14% NOWRAP>$THE_HIST</td>" .
       "<td width=14% NOWRAP>" .
       "<a href=javascript:spawn(\"/SAGE/DKRawDataDownload?ORG=Hs&FILENAME=$FILE_NAME\")>$TAGS_PLUS</a>" .
       "</td>" .
       "<td width=14% NOWRAP>" .
       "<a href=javascript:spawn(\"/SAGE/DKDownload?ORG=Hs&CACHE_ID=$DOWNLOAD_MAPPED_CACHE_ID&FILENAME=$FILE_NAME\")>$MAPPED_TAGS_PLUS</a>" .
       "</td>" .
       "<td width=9% NOWRAP>" .
       "<a href=javascript:spawn(\"/SAGE/DK_Query?ORG=Hs&LIBNAME=$NAME&FILENAME=$FILE_NAME\")>DkView</a>" .
       "</td>" .
       "</tr>";
  }
 
  $db->disconnect();
  $output = $output . "</table>";
  return $output;

}

######################################################################
sub DK_Query_1 {
  my ($base, $org, $libname) = @_;

  ##push @lines, "<br><center>Filename: $filename; Window size: $window_size </center><br><br>";
  my (@lines, @image_map);

  my (@lines, @image_map);
  my ($window_size, $mapped_cache_id, $binned_data_id,
      $first_image_map_cache_id, $image_map_cache_id); 
 
  ## my $dk_cache = new Cache(CACHE_ROOT, DK_CACHE_PREFIX);
  ## my $dk_query_cache = new Cache(CACHE_QUERY_ROOT, DK_CACHE_PREFIX);
  ## my $CACHE_FAIL = 0;
 
  my @chr_order = ("1", "2", "3", "4", "5", "6", "7", "8", "9",
     "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
     "20", "21", "22", "X", "Y");
 
  my ($db, $sql, $stm);
  my ($name, $fielname, $window_size, $mapped_cache_id, $binned_data_id,
      $first_image_map_cache_id, $image_map_cache_id); 
  $db = DBI->connect("DBI:Oracle:" . DB_INSTANCE, DB_USER, DB_PASS);
  if (not $db or $db->err()) {
    print STDERR "Cannot connect to " . DB_USER . "@" . DB_INSTANCE . "\n";
    exit();
  }
 
  $sql = "select NAME, FILE_NAME, WINDOW_SIZE, MAPPED_CACHE_ID, " .
         "BINNED_DATA_ID, FIRST_IMAGE_MAP_CACHE_ID, IMAGE_MAP_CACHE_ID " .
         "from $CGAP_SCHEMA.DK_SAGELIBINFO where NAME = '$libname' ";
 
  $stm = $db->prepare($sql);
  if(not $stm) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "prepare call failed\n";
  }
  if(!$stm->execute()) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "execute call failed\n";
  }

  $stm->bind_columns(\$name, \$fielname, \$window_size, \$mapped_cache_id, 
                     \$binned_data_id, \$first_image_map_cache_id, 
                     \$image_map_cache_id);
  while ($stm->fetch) {
  }
 
  $db->disconnect();

  push @lines, "Window size: $window_size<br><br><br>";
  my $id = $first_image_map_cache_id;
  for my $chr (@chr_order) {
    my $chrmapname = "chrmap" . $chr;
    push @lines, "<img src=\"DKQueryImage?CACHE=$id&CHR=$chr\" border=0 usemap=\"#$chrmapname\"><br>";
    $id++; 
  }
 
  my $cache_filename = $dk_query_cache->FindCacheFile($image_map_cache_id);
  open(IN, "$cache_filename") or die "Can't open $cache_filename.";
 
  while (<IN>) {
    push @lines, $_;
  }
  close (IN);

  return (join "", @lines);

}

######################################################################
sub SAGEDKLibPage_1 {
  my ($base, $libname, $org) = @_;

  my $BASE = $base;

  my ($DUKE_name, $NCBI_name, $keywords);
  my $organism = ($org eq 'Hs') ? "Homo sapiens" : "Mus musculus";
  my ($tags_plus, $tags, $utags);
  my ($tissue, $histology, $preparation, $mutations,
      $patient_age, $patient_sex, $other_info);
  my ($tag_enzyme, $anchor_enzyme, $supplier, $producer,
      $laboratory, $references);

  my ($db, $sql, $stm);
  my ($name, $nametype);
  my ($reference, $pubmed_id);
  my (@ref_array);

  my %nice_enzyme_html = (
    "BsmF I"  => "<i>Bsm</i><font face=\"Times New Roman\">FI</font>",
    "Nla III" => "<i>Nla</i><font face=\"Times New Roman\">III</font>",
    "Mme I"   => "<i>Mme</i><font face=\"Times New Roman\">I</font>"
  );

  my (@rows);

  $db = DBI->connect("DBI:Oracle:" . DB_INSTANCE, DB_USER, DB_PASS);
  if (not $db or $db->err()) {
    print STDERR "Cannot connect to " . DB_USER . "@" . DB_INSTANCE . "\n";
    exit();
  }

  $sql = "select " .
      "name, keywords, " .
      "tags_plus, utags, mapped_tags_plus, mapped_utags, " .
      "the_tiss, the_hist, ORGANISM, METHOD, preparation, mutations, " .
      "patient_age, patient_sex, other_info, " .
      "tag_enzyme, anchor_enzyme, supplier, producer, " .
      "laboratory, reference " .
      "from $CGAP_SCHEMA.dk_sagelibinfo " .
      "where name = '$libname'";

  $stm = $db->prepare($sql);
  if(not $stm) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "prepare call failed\n";
  }
  if(!$stm->execute()) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "execute call failed\n";
  }

  my ($name, $keywords,
      $tags_plus, $utags, $mapped_tags_plus, $mapped_utags,
      $tissue, $histology, $org, $method, $preparation, $mutations,
      $patient_age, $patient_sex, $other_info,
      $tag_enzyme, $anchor_enzyme, $supplier, $producer,
      $laboratory, $reference)
       = $stm->fetchrow_array();
  $stm->finish();

  $tags_plus = Thousands($tags_plus);
  $mapped_tags_plus = Thousands($mapped_tags_plus);
  $utags     = Thousands($utags);
  $mapped_utags     = Thousands($mapped_utags);
  if (defined $nice_enzyme_html{$tag_enzyme}) {
    $tag_enzyme    = $nice_enzyme_html{$tag_enzyme};
  }
  if (defined $nice_enzyme_html{$anchor_enzyme}) {
    $anchor_enzyme = $nice_enzyme_html{$anchor_enzyme};
  }
  if ($tissue eq "mammary gland" && $org eq "Hs") {
    $tissue = "breast";
  }

  ## while(($reference, $pubmed_id) = $stm->fetchrow_array()) {
  ##   if ($pubmed_id) {
  ##     push @ref_array,
  ##       "<a href=" .
  ##       "\"http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?" .
  ##       "cmd=Retrieve&db=PubMed&list_uids=$pubmed_id&dopt=Abstract\"" .
  ##       ">$reference</a>";
  ##   } else {
  ##     push @ref_array, $reference
  ##   }
  ## }

  ## $references = join("<br>", @ref_array);

  $references = $reference;

  $db->disconnect();

  push @rows, DividerBar("Library ID");
  push @rows,
      "<BR>" .
      "<table width=95% cellpadding=1>";
  push @rows,
      "<tr><td valign=top width=30%><b>SAGE DK Library Name:</b></td>" .
      "<td>$name</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Organism:</b></td><td>$organism</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Library Keywords:</b></td>" .
      "<td>$keywords</td></tr>";
  push @rows,
      "</table><br>";

  push @rows, DividerBar("Tag Info");
  push @rows,
      "<BR>" .
      "<table width=95% cellpadding=1>";
  push @rows,
      "<tr><td valign=top width=30%><b>#Total tags:</b></td>" .
      "<td>$tags_plus</td></tr>";
  push @rows,
      "<tr><td valign=top width=30%><b>#Mapped Total tags:</b></td>" .
      "<td>$mapped_tags_plus</td></tr>";
  ## push @rows,
  ##     "<tr><td valign=top><b>#Tags excluding linkers:</b></td>" .
  ##     "<td><a href=\"$BASE/sagecgi/SimpleTagList.pl?" .
  ##     "BASE=$BASE" . "\&LID=$lid\">$tags</a></td></tr>";
  push @rows,
      "<tr><td valign=top><b>#Unique tags:</b></td>" .
      "<td>$utags</td></tr>";
  push @rows,
      "<tr><td valign=top><b>#Mapped Unique tags:</b></td>" .
      "<td>$mapped_utags</td></tr>";
  push @rows,
      "</table><br>";

  push @rows, DividerBar("Tissue Info");
  push @rows,
      "<BR>" .
      "<table width=95% cellpadding=1>";
  push @rows,
      "<tr><td valign=top width=30%><b>Tissue:</b></td>" .
      "<td>$tissue</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Cell/Histology type:</b></td>" .
      "<td>$histology</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Tissue preparation:</b></td>" .
      "<td>$preparation</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Mutations:</b></td>" .
      "<td>$mutations</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Patient age:</b></td>" .
      "<td>$patient_age</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Sex:</b></td>" .
      "<td>$patient_sex</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Other info:</b></td>" .
      "<td>$other_info</td></tr>";
  push @rows,
      "</table><br>";

  push @rows, DividerBar("Library Preparation Info");
  push @rows,
      "<BR>" .
      "<table width=95% cellpadding=1>";
  push @rows,
      "<tr><td valign=top width=30%><b>Tagging enzyme:</b></td>" .
      "<td>$tag_enzyme</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Anchoring enzyme:</b></td>" .
      "<td>$anchor_enzyme</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Tissue or cell line supplier:</b></td>" .
      "<td>$supplier</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Library preparer:</b></td>" .
      "<td>$producer</td></tr>";
  push @rows,
      "<tr><td valign=top><b>Prepared in lab of:</b></td>" .
      "<td>$laboratory</td></tr>";
  push @rows,
      "<tr><td valign=top><b>References:</b></td>" .
      "<td>$references</td></tr>";
  push @rows,
      "</table><br>";


  return join("\n", @rows);
}

######################################################################
sub UploadExperimentalFile_1 {
  my ($base, $org, $filename, $filedata) = @_;
 
  $BASE = $base;
 
  my (%tag2allinfo, %chr_position2allinfo);
  my (@all_lines, @good_lines, @dup_lines, @no_result_lines);

  my ($list);
  my ($sql, $stm);
  my %goodInput;
  my %tags;
  my $lines;
  my $count = 0;
  my (%dup_tags);
  my %exp;
  my (%freq, %chr_2_mapped_id, %chr_2_smoothed_id);
  my %mapped_tags;
  my %not_mapped_tags;
  my @mapped_lines;
  my @input_tags;
  my %unique_input_tags;
  my $total_input_tags;
  my $total_input_unique_tags;
  my $total_mapped_tags;
  my $total_mapped_unique_tags;
  my $map_f = "/share/content/CGAP/SAGE/data/dkmap.dat";
 
  if( $filename eq "" ) {
    return "Please enter the file name.";
  }

  my @tempArray;
  if( $filedata =~ /\r/ ) {
    @tempArray = split "\r", $filedata;
  }
  else {
    @tempArray = split "\n", $filedata;
  }
 
  for (my $t = 0; $t < @tempArray; $t++ ) {
    $tempArray[$t] =~  s/^\s+//;
    $tempArray[$t] =~  s/\s+$//;
    if ($tempArray[$t] eq "") {
      next;
    }
    else {
      my ($tag, $freq) = split /\t/, $tempArray[$t];
      $exp{$tag} += $freq;
      $total_input_tags = $total_input_tags + $freq;
      $unique_input_tags{$tag} = 1;
    }
  }

  $total_input_unique_tags = scalar(keys %unique_input_tags);
  my $mapped;
  my $not_mapped;

  my ($db, $sql, $stm);
  $db = DBI->connect("DBI:Oracle:" . DB_INSTANCE, DB_USER, DB_PASS);
  if (not $db or $db->err()) {
    print "Cannot connect to " . DB_USER . "@" . DB_INSTANCE . "\n";
    exit();
  }
 
  $sql = "select TAG, CHROMOSOME, POS, STRAND, TAGNUM " .
         "from $CGAP_SCHEMA.DKMAP order by CHROMOSOME, TAGNUM";
 
  $stm = $db->prepare($sql);
  if(not $stm) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "prepare call failed\n";
  }
  if(!$stm->execute()) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "execute call failed\n";
  }
  while(my ($tag, $chr, $pos, $strand, $tag_num) = $stm->fetchrow_array()) {
    my $freq;
    if (defined $exp{$tag}) {
      $freq = $exp{$tag};
      $total_mapped_tags = $total_mapped_tags + $freq;
      $total_mapped_unique_tags++;
    } else {
      $freq = 0;
    }
    push @{ $freq{$chr} }, $freq;
  }
 
  $db->disconnect();
 
  my $overall_avg = $total_mapped_tags/$N_VIRTUAL_TAGS;
 
  for my $chr (@chr_order) {
    for my $f (@{ $freq{$chr} }) {
      $f = sprintf("$f\t%.2f\n", $f / $overall_avg)
    }
  }

  my $total_not_mapped_tags = $total_input_tags - $total_mapped_tags;
  my $total_not_mapped_unique_tags = 
          $total_input_unique_tags - $total_mapped_unique_tags;

  my @chr_mapped_ids;
  for my $chr (@chr_order) {
    my $data = join "", @{ $freq{$chr} };
    $chr_2_mapped_id{$chr} = WriteDKToCache($data, $chr);
    if( $chr_2_mapped_id{$chr} == 0 ) {
      print "There is a error in the DKView process.";
      return "";
    }
    push @chr_mapped_ids,  $chr . "_" .  $chr_2_mapped_id{$chr};
  }

  my @lines; 
  
  my $mapped_cache_id = (join ",", @chr_mapped_ids);

  push @lines, "<form name=\"dkdownloadform\" action=\"DKDownload\" method=post target=_blank>\n" .
    "<input type=\"hidden\" name=\"CACHE_ID\" value=$mapped_cache_id>\n" .
    "<input type=\"hidden\" name=\"FILENAME\" value=$filename>\n" .
    "<input type=\"hidden\" name=\"ORG\" value=$org>\n" .
    "<blockquote>" .
    "<table border=\"1\" width=80% cellpadding=2>\n" .
    "<tr bgcolor=\"#666699\">" .
    "<td width=20%><font color=\"white\"><b>&nbsp;</b></font></td>\n" .
    "<td width=20%><font color=\"white\"><b>Mapped</b></td>" .
    "<td NOWRAP width=20%><font color=\"white\"><b>Not Mapped</b></td>" .
    "<td NOWRAP width=20%><font color=\"white\"><b>Total</b></td>" .
    "</tr>\n" .
    "<tr>" .
    "<td width=20%>Total tags in input</td>\n" .
    "<td width=20%>$total_mapped_tags</td>" .
    "<td width=20%>$total_not_mapped_tags</td>" .
    "<td width=20%>$total_input_tags</td>" .
    "</tr>\n" .
    "<tr>" .
    "<td width=20%>Unique tags in input</td>\n" .
    "<td width=20%>$total_mapped_unique_tags</td>" .
    "<td width=20>$total_not_mapped_unique_tags</td>" .
    "<td width=20>$total_input_unique_tags</td>" .
    "</tr>\n" .
    ## "</tr>\n" .
    "</table>\n" .
    "<br><br>" .
    "<input type=submit value=\"Download mapped tags\">" .
    ## "</blockquote>\n" .
    ## "<blockquote>" .
    "</form>\n" .
    "<form name=\"dkform\" action=\"DKView\") method=post target=_blank>\n" .
    "<input type=\"hidden\" name=\"CACHE_ID\" value=$mapped_cache_id>\n" .
    "<input type=\"hidden\" name=\"FILENAME\" value=$filename>\n" .
    "<input type=\"hidden\" name=\"ORG\" value=$org>\n" .
    "<table border=\"0\" width=90% cellpadding=2>\n" .
    "<tr><td>&nbsp;\n" .
    "</td>\n" .
    "<td>&nbsp;\n" .
    "</td></tr>\n" .
    "<tr>" .
    "<td colspan=2 bgcolor=\"336699\" align=center><font color=\"FFFFFF\">\n" .
    "<B>Enter window size for smooting data</B>\n" .
    "</font></td></tr><br>\n" .
        "<tr><td>&nbsp;\n" .
    "</td>\n" .
    "<td>&nbsp;\n" .
    "</td></tr>\n" .
    "<tr>\n" .
    "  <td align=left width=45%>1. Enter the window size.</td>\n" .
    "  <td align=left>\n" .
    "  <input type=text name=\"WINDOWSIZE\" value=\"200\" size=30>\n" .
    "  </td>\n" .
    "</tr>\n" . 
    "<tr>\n" .
    "  <td align=left width=45%>2. Enter the amplification width(tags).</td>\n" .
    "  <td align=left>\n" .
    "  <input type=text name=\"AMPWIDTH\" value=\"75\" size=30>\n" .
    "  </td>\n" .
    "</tr>\n" . 
    "<tr>\n" .
    "  <td align=left width=45%>3. Enter the amplification change.</td>\n" .
    "  <td align=left>\n" .
    "  <input type=text name=\"AMPTHRESHHOLD\" value=\"7\" size=30>\n" .
    "  </td>\n" .
    "</tr>\n" . 
    "<tr>\n" .
    "  <td align=left width=45%>4. Enter the deletion width(tags).</td>\n" .
    "  <td align=left>\n" .
    "  <input type=text name=\"DELWIDTH\" value=\"50\" size=30>\n" .
    "  </td>\n" .
    "</tr>\n" . 
    "<tr>\n" .
    "  <td align=left width=45%>5. Enter the deletion change.</td>\n" .
    "  <td align=left>\n" .
    "  <input type=text name=\"DELTHRESHHOLD\" value=\"0.1\" size=30>\n" .
    "  </td>\n" .
    "</tr>\n" . 
    "<tr>\n" .
    "<td>6. Submit query:</td>\n" .
    "<td> " .
    "<input type=button onclick=\"dkform.submit()\" value=\"Submit Query\">" .
    "</td>\n" .
    "</tr>\n" .
    "<tr><td>&nbsp;\n" .
    "</td>\n" .
    "<td>&nbsp;\n" .
    "</td></tr>\n" .
    "</table>\n" .
    "</blockquote>\n" .
    "</form>\n";
  return (join "", @lines);
}

######################################################################
sub DKDownload_1 {
  my ($base, $mapped_cache_id) = @_;
  
  my (%freq, %chr_2_id);

  my @tmp = split ",", $mapped_cache_id; 
  for (my $i=0; $i<@tmp; $i++) {
    my ($chr, $id) = split "_", $tmp[$i];
    $chr_2_id{$chr} = $id;
  }

  my ($chromo, $start_pos, $end_pos); 
  my $need_tag_num = 0;
  get_data_from_dkmap( $chromo, $start_pos, $end_pos, $need_tag_num);
 
  my @output;
  push @output, "Tag\tChr\tPosition\tStrand\tFreq\n";

  for my $chr (@chr_order) {
    if ($dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr) eq $CACHE_FAIL) {
      return "Cache expired";
    }
    my $filename = $dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr);
    open(IN, "$filename") or die "Can't open $filename.";
    my $count = 0;
    while (<IN>) {
      chop;
      my ($raw_freq, $normalized_freq) = split /\t/, $_;
      if( $raw_freq != 0 ) {
        push @output, @{ $dkmap{$chr} }[$count] . "\t" . $raw_freq . "\n";
      }
      $count++;
    }
    close (IN);
  }

  return "", @output;
}

######################################################################
sub DKRegionDownload_1 {

  my ($base, $org, $chr, $mapped_cache_id, 
                            $start_pos, $end_pos, $filename) = @_;

  my (%freq, %chr_2_id);
 
  my @tmp = split ",", $mapped_cache_id;
  for (my $i=0; $i<@tmp; $i++) {
    my ($chr, $id) = split "_", $tmp[$i];
    $chr_2_id{$chr} = $id;
  }
 
  my ($start, $end); ## need to use mapped file, so get all for the chr
  my $need_tag_num = 0;
  get_data_from_dkmap( $chr, $start, $end, $need_tag_num);
 
  my @output;
  push @output, "Tag\tChr\tPosition\tStrand\tFreq\n";
 
  if ($dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr) eq $CACHE_FAIL) {
    return "Cache expired";
  }
  my $filename = $dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr);
  open(IN, "$filename") or die "Can't open $filename.";
  my $count = 0;
  while (<IN>) {
    chop;
    my ($raw_freq, $normalized_freq) = split /\t/, $_;
    my ($tag, $chr, $pos, $strand) = split "\t", @{ $dkmap{$chr} }[$count]; 
    if( $pos >= $start_pos and $pos <= $end_pos ) {
      if( $raw_freq != 0 ) {
        push @output, @{ $dkmap{$chr} }[$count] . "\t" . $raw_freq . "\n";
      }
    }
    $count++;
  }
  close (IN);
 
  return "", @output;
}

######################################################################
sub DKRawDataDownload_1 {
  my ($base, $filename) = @_;

  my $raw_file = CACHE_QUERY_ROOT . $filename;
  open(IN, "$raw_file") or die "Can't open $raw_file.";
 
  my @output;
  while (<IN>) {
    push @output, $_;
  }
  close (IN);

  return "", @output;
}

######################################################################
sub DKView_1 {
  my ($base, $org, $mapped_cache_id, $window_size, $filename,
      $DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, $AMP_THRESHHOLD) = @_;
 
  my %freq;
  my @mapped_lines;
  my $bin_size = BIN_SIZE;
  my ($tag, $chr, $pos, $strand, $tag_num, $freq);
  my (%mapped_data, $n_virtual_tags, $sum_freq);
  my (%freq);
  my (@window_info);
  my $data;
  my (%chr_2_id);
 
  my @tmp = split ",", $mapped_cache_id;
  for (my $i=0; $i<@tmp; $i++) {
    my ($chr, $id) = split "_", $tmp[$i];
    $chr_2_id{$chr} = $id;
  }
 
  if ($window_size % 2 != 0) {
    $window_size++;
  }
  my $half_window = $window_size / 2;
   
  for my $chr (@chr_order) {
    if ($dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr) eq $CACHE_FAIL) {
      return "Cache expired";
    }
    my $filename = $dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr);
    open(IN, "$filename") or die "Can't open $filename.";
    while (<IN>) {
      chop;
      my ($raw_freq, $normalized_freq) = split /\t/, $_;
      push @{ $freq{$chr} }, $normalized_freq;
    }
    close (IN);
  }

  my %n_virtual_tags_per_chr;
  for my $chr (@chr_order) {
    $n_virtual_tags_per_chr{$chr} = @{ $freq{$chr} };
  }

  for $chr (@chr_order) {
    for (my $tag_num = 0; $tag_num < @{ $freq{$chr} }; $tag_num++) {
      $window_value{$chr}[$tag_num] = sprintf("%.2f",
        ComputeWindow($chr, $tag_num, 
        $half_window, \%n_virtual_tags_per_chr, $window_size, \%freq));
    }
  }

  my (@chr_smoothed_ids);
  for my $chr (@chr_order) {
    my $data = (join "\n", @{ $window_value{$chr} }) . "\n";
    my $chr_2_smoothed_id = WriteDKToCache($data, $chr);
    if( $chr_2_smoothed_id == 0 ) {
      print "There is a error in the DKView process.";
      return "";
    }
    push @chr_smoothed_ids,  $chr . "_" .  $chr_2_smoothed_id;
  }
 
  my $smoothed_cache_id = (join ",", @chr_smoothed_ids);


  Hunt_anomalies ($smoothed_cache_id, $DEL_WIDTH, $DEL_THRESHHOLD,
                                      $AMP_WIDTH, $AMP_THRESHHOLD);

  print Make_Display_amp_del_page( 
               $org, $smoothed_cache_id, $bin_size, $window_size,
               $mapped_cache_id, $DEL_WIDTH, $DEL_THRESHHOLD, 
               $AMP_WIDTH, $AMP_THRESHHOLD, $filename); 

}

######################################################################
sub ComputeWindow {
  my ($chr, $tag_num, $half_window, $n_virtual_tags_per_chr_ref,
      $window_size, $freq_ref) = @_;
 
  ## actually, the window is half_window tags on either side
  ## of the focal tag
 
  my $j;
  my %freq = %{$freq_ref};
  my $n_tags_in_chr = $$n_virtual_tags_per_chr_ref{$chr};
  if ($tag_num - $half_window < 0) {
    $j = $tag_num;
  } elsif ($tag_num + $half_window > $n_tags_in_chr) {
    $j = $tag_num - $n_tags_in_chr;
  } else {
    $j = $half_window;
    if ($tag_num > $j && $tag_num < $n_tags_in_chr - $half_window - 1) {
      return (
          $window_value{$chr}[$tag_num - 1] * ($window_size + 1) -
          $freq{$chr}[$tag_num - $half_window - 1] +
          $freq{$chr}[$tag_num + $half_window]
        ) / ($window_size + 1);
    }
  }
 
  ## it's one end or the other
 
  my $sum;
  for (my $i = $tag_num - $j; $i <= $tag_num + $j; $i++) {
    $sum += $freq{$chr}[$i];
  }
  return $sum / (($j * 2) + 1);
}

######################################################################
sub DKView_All_1 {
  my ($base, $org, $mapped_cache_id, $smoothed_cache_id,,
      $window_size, $filename,
      $DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, $AMP_THRESHHOLD) = @_;

  my $n;
  my ($tag, $chr, $pos, $strand, $tag_num, $freq, $normal_freq, $window_val);
  my ($last_chr);
  my (@lines, %chr_2_image_id, %chr_2_mapped_id, %chr_2_smoothing_id);
  my (@image_map);
  my (%chr_2_id, %window_vals);
  my $bin_size = BIN_SIZE;
  my (%max);
  for(my $i=0; $i<@chr_order; $i++) {
    $max{$chr_order[$i]} = 0;
  }

  my @tmp = split ",", $smoothed_cache_id;
  for (my $i=0; $i<@tmp; $i++) {
    my ($chr, $id) = split "_", $tmp[$i];
    $chr_2_id{$chr} = $id;
  }
 
  for my $chr (@chr_order) {
    if ($dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr) eq $CACHE_FAIL) {
      return "Cache expired";
    }
    my $filename = $dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr);
    open(IN, "$filename") or die "Can't open $filename.";
    while (<IN>) {
      chop;
      push @{ $window_vals{$chr} }, $_;
    }
    close (IN);
  }
 
  my ($db, $sql, $stm);
  $db = DBI->connect("DBI:Oracle:" . DB_INSTANCE, DB_USER, DB_PASS);
  if (not $db or $db->err()) {
    print "Cannot connect to " . DB_USER . "@" . DB_INSTANCE . "\n";
    exit();
  }
 
  $sql = "select TAG, CHROMOSOME, POS, STRAND, TAGNUM " .
         "from $CGAP_SCHEMA.DKMAP order by CHROMOSOME, TAGNUM";
 
  $stm = $db->prepare($sql);
  if(not $stm) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "prepare call failed\n";
  }
  if(!$stm->execute()) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "execute call failed\n";
  }
  while(my ($tag, $chr, $pos, $strand, $tag_num) = $stm->fetchrow_array()) {

    if ($last_chr && $last_chr ne $chr) {
      DoBin($last_chr, $n, $bin_size, \%max);
      $n = 0;
    }
    $last_chr = $chr;
    push @window_val, $window_vals{$chr}[$n];
    push @start, $pos;
    $n++;
    if ($n % $bin_size == 0) {
      DoBin($chr, $n, $bin_size, \%max);
    }
  }
 
  $db->disconnect();
 
  if ($n % $bin_size > 0) {
    DoBin($chr, $n, $bin_size, \%max);
  }
 
  for my $chr (@chr_order) {
    my $chrmapname = "chrmap" . $chr;
    push @image_map, "<map name=\"$chrmapname\">";
    $chr_2_image_id{$chr} =  
      Graph($org, $chr, \@image_map, $window_size, 
            $filename, $max{$chr}, $mapped_cache_id,
            $DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, $AMP_THRESHHOLD);
      ## Graph($chr, \@image_map, $window_info_cache_id, $window_size, 
      ##       $filename, $binned_data_id, $max{$chr}, $mapped_cache_id);
    push @image_map, "</map>";
  }
 
  ## push @lines, "<br><center>Filename: $filename; Window size: $window_size </center><br><br>";

  for my $chr (@chr_order) {
    my $id = $chr_2_image_id{$chr};
    my $chrmapname = "chrmap" . $chr;
    push @lines, "<img src=\"DKImage?CACHE=$id&CHR=$chr\" border=0 usemap=\"#$chrmapname\"><br>";
  }

  push @lines, @image_map;

  ## for create pre_process data
  ## my $data = join "", @image_map;
  ## my $image_cache_id = WriteDKDataToCache($data);
  ## if( $image_cache_id == 0 ) {
  ##   return "There is a error in the DKView process.";
  ## }
  ## print "8888:  $image_cache_id <br>";

  return (join "", @lines);
}
 
######################################################################
sub DoBin {
  my ($chr, $n, $bin_size, $max_ref) = @_;
 
  my $bn = int($n / $bin_size);
  if ($n % $bin_size > 0) {
    $bn++;
  }
  my $s_pos = $start[0];
  my $e_pos = $start[$#start];
  my $mid = int(@window_val / 2);
  my $avg = $window_val[$mid];
  push @{ $binned_data{$chr} }, join("\t",
      $bn,
      $chr,
      $s_pos,
      $e_pos,
      $n - scalar(@window_val) + 1,
      $n,
      $avg
    );

  if( ($n - scalar(@window_val) + 1) > 1 ) {
    if( $avg > $$max_ref{$chr} ) {
      $$max_ref{$chr} = $avg;
    }
  }

  undef @start;
  undef @end;
  undef @window_val;
}
 
######################################################################
sub Graph {
  my($org, $chr, $image_map_ref, $window_size, 
     $filename, $max, $mapped_cache_id,
     $DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, $AMP_THRESHHOLD) = @_;
 
  ## my($chr, $image_map_ref, $window_info_cache_id, $window_size, 
  ##    $filename, $binned_data_id, $max, $mapped_cache_id) = @_;
 
use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }
  my $GRAPH_HEIGHT        = 200;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * @{ $binned_data{$chr} };
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 30;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 200;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{blue}        = $im->colorAllocate(0,0,255);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
  $COLORS{green}       = $im->colorAllocate(0,255,0);

  my $color;

  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );
 
  if( $max >=0.5 and $max <= 4 ) {
    for (my $y0 = $GRAPH_HEIGHT; $y0 >= 0; $y0 = $y0 - 50) {
      my $x0 = 0;
      $im->string(gdSmallFont, $x0, $y0, int(($GRAPH_HEIGHT - $y0)/50), $COLORS{black});
    }
  }
  elsif ($max > 4) {
    my $x0 = 0;
    my $y0 = $GRAPH_HEIGHT;
    $im->string(gdSmallFont, $x0, $y0, 0, $COLORS{red});
    $y0 = $GRAPH_HEIGHT - int(50 * ($max/($max + 1)) * 4);
    $im->string(gdSmallFont, $x0, $y0, $max, $COLORS{red});
  }
  else {
    my $x0 = 0;
    my $y0 = $GRAPH_HEIGHT;
    $im->string(gdSmallFont, $x0, $y0, 0, $COLORS{red});
    $y0 = $GRAPH_HEIGHT - int(50 * ($max/($max + 0.1)) * 4);
    $im->string(gdSmallFont, $x0, $y0, $max, $COLORS{red});
  }

  my $last_val;

  ## start from 0 or 1?
  ## for (my $i = 1; $i < @{ $binned_data{$chr} } - 1; $i++ ) {
  for (my $i = 0; $i < @{ $binned_data{$chr} } - 1; $i++ ) {

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
                                         = split("\t", $binned_data{$chr}[$i]);

    my $x0 = $PIX_PER_INTERVAL * ($i - 1);
    my $x1 = $PIX_PER_INTERVAL * $i;
    my $y0;
    if( $max >= 0.5 and $max <= 4 ) {
      $y0 = $GRAPH_HEIGHT - int(50 * $last_val);
    }
    elsif( $max > 4 ) {
      $y0 = $GRAPH_HEIGHT - int(50 * ($last_val/($max + 1)) * 4);
    }
    else {
      $y0 = $GRAPH_HEIGHT - int(50 * ($last_val/($max + 0.1)) * 4);
    }
    my $y1;
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }

    $color = $COLORS{red};

    if ($x0 == $x1) {
      $im->line (
          $x0+30,
          $y0,
          $x1+30,
          $y1,
          $color
      );
    } else {
      $im->filledRectangle (
          $x0+30,
          $y0,
          $x1+30,
          $y1,
          $color
      );
    }
    ## if( $chr == 1 and $i < 200 ) {
    ##   print "8888: $x0+30, $y0, $x1+30, $y1 <br>"; 
    ## }
    $last_val = $value;
    my $x0_pos = $x0+30;
    my $x1_pos = $x1+30;
    push @{ $image_map_ref },
      "<area shape=rect coords=\"$x0_pos,$y0,$x1_pos,$y1\" " .
      "href=javascript:spawn(\"DKViewDetail?ORG=$org&CHR=$chr&POS=$i&START_POS=&END_POS=&WINDOWSIZE=$window_size&FILENAME=$filename&MAPPED_DATA_CACHE_ID=$mapped_cache_id&DELWIDTH=$DEL_WIDTH&DELTHRESHHOLD=$DEL_THRESHHOLD&AMPWIDTH=$AMP_WIDTH&AMPTHRESHHOLD=$AMP_THRESHHOLD\")>";
  }
  
  if( $max >= 0.5 and $max <= 4 ) {
    my $x0 = 0 + 30;
    my $x1 = $GRAPH_WIDTH + 30;
    my $y0 = $GRAPH_HEIGHT - int(50 * 1);
    my $y1 = $y0;
    $im->line($x0, $y0, $x1, $y1, $COLORS{white});
  }

  $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+10, "Chromosome " . $chr,
    $COLORS{black});
 
  ## print "8888: call WriteDKGEToCache <br>";
  return WriteDKToCache($im->png, $chr)
}
 
 
######################################################################

sub DKViewDetail_1 {
 
  my ($base, $org, $chr_in, $pos_in, $start_pos_in, $end_pos_in, $window_size, 
      $filename, $mapped_data_cache_id,
      $DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, $AMP_THRESHHOLD) = @_;
 
  my $bin_size = BIN_SIZE;
  my $CHOOSE_WAY = 2;
 
  my ($n);
  my ($tag, $chr, $pos, $strand, $tag_num, $freq, $normal_freq, $window_val);
  my ($last_chr);
  my (@lines, $chr_2_image_id, $high_chr_2_image_id, $low_chr_2_image_id);
  my (@image_map);
  my ($start_pos, $end_pos);
  my (%freq, %max, %window_vals, @dkmap);
  my ($detail_max, $detail_low_max, $detail_high_max);
  my (@detail_data);
  for(my $i=0; $i<@chr_order; $i++) {
    $max{$chr_order[$i]} = 0;
  }
  $detail_max = 0;

  my (%chr_2_id);
 
  my @tmp = split ",", $mapped_data_cache_id;
  for (my $i=0; $i<@tmp; $i++) {
    my ($chr, $id) = split "_", $tmp[$i];
    $chr_2_id{$chr} = $id;
  }
 
  if ($window_size % 2 != 0) {
    $window_size++;
  }
  my $half_window = $window_size / 2;

  if ($dk_cache->FindDKCacheFile($chr_2_id{$chr_in}, $chr_in) eq $CACHE_FAIL) {
    return "Cache expired";
  }
  my $filename = $dk_cache->FindDKCacheFile($chr_2_id{$chr_in}, $chr_in);
  open(IN, "$filename") or die "Can't open $filename.";
  while (<IN>) {
    chop;
    my ($raw_freq, $normalized_freq) = split /\t/, $_;
    push @{ $freq{$chr_in} }, $normalized_freq;
  }
  close (IN);

  my %n_virtual_tags_per_chr;
  $n_virtual_tags_per_chr{$chr_in} = @{ $freq{$chr_in} };

  for (my $tag_num = 0; $tag_num < @{ $freq{$chr_in} }; $tag_num++) {
    $window_value{$chr_in}[$tag_num] = sprintf("%.2f",
        ComputeWindow($chr_in, $tag_num,
        $half_window, \%n_virtual_tags_per_chr, $window_size, \%freq));
  }

  Do_window_info_data( $chr_in, $bin_size, $CHOOSE_WAY, $filename );

  ($detail_max, $start_pos_in, $end_pos_in, @detail_data) = 
             Get_detail_max_and_data( $chr_in, $pos_in, $start_pos_in, 
                                      $end_pos_in, $CHOOSE_WAY );

  if( $detail_max >= 4 ) {
    $chr_2_image_id = 
       Graph_detail_high($chr_in, $pos_in, $start_pos_in, $end_pos_in,
                                  $CHOOSE_WAY, $detail_max, \@detail_data);
  }
  elsif( $detail_max < 0.5 ) {
    $chr_2_image_id = 
       Graph_detail_low($chr_in, $pos_in, $start_pos_in, $end_pos_in,
                                 $CHOOSE_WAY, $detail_max, \@detail_data);
  }
  else {
    $chr_2_image_id = 
       Graph_detail($chr_in, $pos_in, $start_pos_in, $end_pos_in,
                              $CHOOSE_WAY, $detail_max, \@detail_data);
  }
 
  push @lines, Make_detail_html($org, $chr_in, $pos_in, $start_pos_in, 
                                $end_pos_in, $window_size,
                                $filename, $mapped_data_cache_id,
                                $DEL_WIDTH, $DEL_THRESHHOLD, 
                                $AMP_WIDTH, $AMP_THRESHHOLD); 
 
  push @lines, 
        "<img src=\"DKImage?CACHE=$chr_2_image_id&CHR=$chr_in\" border=0><br>";
 
  my $chrmapname = "chrmap" . $chr_in;
  push @image_map, "<map name=\"$chrmapname\">";
  my $id;
  $id = Graph_chr($org, $chr_in, \@image_map, $pos_in, $start_pos_in, 
                  $end_pos_in,
                  $window_size, $filename,  
                  $mapped_data_cache_id, $DEL_WIDTH, $DEL_THRESHHOLD, 
                  $AMP_WIDTH, $AMP_THRESHHOLD);

  push @image_map, "</map>";
 
  push @lines, "<img src=\"DKImage?CACHE=$id&CHR=$chr_in\" border=0 usemap=\"#$chrmapname\"><br>";
  push @lines, @image_map;

  return (join "", @lines);
}
 
######################################################################
sub Do_window_info_data {
  my ($chr_in, $bin_size, $CHOOSE_WAY, $filename) = @_;
  my ($n, @dkmap, %max);

  my ($db, $sql, $stm);
  $db = DBI->connect("DBI:Oracle:" . DB_INSTANCE, DB_USER, DB_PASS);
  if (not $db or $db->err()) {
    print "Cannot connect to " . DB_USER . "@" . DB_INSTANCE . "\n";
    exit();
  }
 
  $sql = "select TAG, CHROMOSOME, POS, STRAND, TAGNUM " .
         "from $CGAP_SCHEMA.DKMAP where CHROMOSOME = '$chr_in' " .
         "order by TAGNUM";
 
  $stm = $db->prepare($sql);
  if(not $stm) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "prepare call failed\n";
  }
  if(!$stm->execute()) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "execute call failed\n";
  }
 
  $n = 0;
  while(my ($tag, $chr, $pos, $strand, $tag_num) = $stm->fetchrow_array()) {
    push @dkmap, (join "\t", $tag, $chr, $pos, $strand, $tag_num);
    push @window_val, $window_value{$chr}[$n];
    push @start, $pos;
    if ($n % $bin_size == 0) {
      DoBin($chr_in, $n, $bin_size, \%max);
    }
    $n++;
  }
 
  $db->disconnect();
 
  if ($n % $bin_size > 0) {
    DoBin($chr_in, $n, $bin_size, \%max);
  }
 
  undef @start;
  undef @end;
  undef @window_val;
 
  for ($n = 0; $n < @dkmap; $n++) { 
    my ($tag,$chr,$pos,$strand,$tag_num) = split /\t/, $dkmap[$n];
    push @window_val, $window_value{$chr_in}[$n];
    push @start, $pos;
    if ($n % $CHOOSE_WAY == 0) {
      DoBin_detail($chr_in, $n, $bin_size);
    }
  }
  if ($n % $bin_size > 0) {
    DoBin_detail($chr_in, $n, $bin_size);
  }
}

######################################################################
sub Get_detail_max_and_data {
  my ($chr_in, $pos_in, $start_pos_in, $end_pos_in, $CHOOSE_WAY) = @_;

  my ($detail_max, @detail_data);
  ## get $detail_max and @detail_data
  if( $start_pos_in ne "" and $end_pos_in ne "" ) {
    for (my $i = 0; $i < @{ $binned_data_detail{$chr_in} } - 1; $i++ ) {
      my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
                               = split("\t", $binned_data_detail{$chr_in}[$i]);
 
      if( $end_pos < $start_pos_in or $start_pos > $end_pos_in ) {
        next;
      }
      push @detail_data, $binned_data_detail{$chr_in}[$i];
      if( $value > $detail_max ) {
        $detail_max = $value;
      }
    }
  }
  elsif ( $pos_in ne "" ) {
    my $current_pos = ($pos_in-1)*BIN_SIZE/$CHOOSE_WAY;
    for (my $i = 0; $i < @{ $binned_data_detail{$chr_in} } - 1; $i++ ) {
      if($i >= $current_pos - $DETAIL_WIDTH 
                    and $i <= $current_pos + $DETAIL_WIDTH) {
        push @detail_data, $binned_data_detail{$chr_in}[$i];
        my ($bin_num,$chr,$start_pos,$end_pos,$start_tag,$end_tag,$value)
                                = split("\t", $binned_data_detail{$chr_in}[$i]);
        if( $value > $detail_max ) {
          $detail_max = $value;
        }
      }
    }
    my ($bin_num,$chr,$start_pos,$end_pos,$start_tag,$end_tag,$value) 
                                              = split("\t", $detail_data[0]);
    $start_pos_in = $start_pos;
    my $size = @detail_data;
    my ($bin_num,$chr,$start_pos,$end_pos,$start_tag,$end_tag,$value)
                                      = split("\t", $detail_data[$size - 1]);
    $end_pos_in = $start_pos;
  }

  return ($detail_max, $start_pos_in,  $end_pos_in, @detail_data);

}

######################################################################
sub DoBin_detail {
  my ($chr, $n, $bin_size) = @_;
  ## $flag = 1 for low, 2 for normal, 3 for high
 
  my $bn = int($n / $bin_size);
  
  if ($n % $bin_size > 0) {
    $bn++;
  }
  my $s_pos = $start[0];
  my $e_pos = $start[$#start];
  my $mid = int(@window_val / 2);
  my $avg = $window_val[$mid];
  push @{ $binned_data_detail{$chr} }, join("\t",
            $bn,
            $chr,
            $s_pos,
            $e_pos,
            $n - scalar(@window_val) + 1,
            $n,
            $avg
          );

  undef @start;
  undef @end;
  undef @window_val;
}
 
######################################################################
sub  GetDetailBinDataFromCache {
  my ($chr_in, $filename) = @_;
  ## $flag = 1 for low, 2 for normal, 3 for high
 
  my @tmp = split "DK", $filename; ## since no slash in the name 
                                   ## to separated the path and name
                                   ## so use this bad way to get the name
  my $length = @tmp;
  my $file_name = "DK". $tmp[$length - 1];
  my ($db, $sql, $stm);
  my ($normal_detail_bin_data_id, $low_detail_bin_data_id,
      $high_detail_bin_data_id);
  my ($FIRST_DETAIL_BINNED_DATA_ID);

  $db = DBI->connect("DBI:Oracle:" . DB_INSTANCE, DB_USER, DB_PASS);
  if (not $db or $db->err()) {
    print STDERR "Cannot connect to " . DB_USER . "@" . DB_INSTANCE . "\n";
    exit();
  }
 
  $sql = "select FIRST_DETAIL_BINNED_DATA_ID " .
         "from $CGAP_SCHEMA.DK_SAGELIBINFO where FILE_NAME = '$file_name' ";
 
  $stm = $db->prepare($sql);
  if(not $stm) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "prepare call failed\n";
  }
  if(!$stm->execute()) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "execute call failed\n";
  }
 
  $stm->bind_columns(\$FIRST_DETAIL_BINNED_DATA_ID);
  while ($stm->fetch) {
    if( $chr_in eq "X" ) {
      $normal_detail_bin_data_id = $FIRST_DETAIL_BINNED_DATA_ID  - 1 + 23;
    }
    elsif( $chr_in eq "Y" ) {
      $normal_detail_bin_data_id = $FIRST_DETAIL_BINNED_DATA_ID  - 1 + 24;
    }
    else { 
      $normal_detail_bin_data_id = 
                               $FIRST_DETAIL_BINNED_DATA_ID + ($chr_in - 1);
    }
  }
 
  $db->disconnect();

  if ($dk_query_cache->FindDKCacheFile($normal_detail_bin_data_id, $chr_in) 
                eq $CACHE_FAIL) {
    return "Cache expired";
  }
  my $filename = 
    $dk_query_cache->FindDKCacheFile($normal_detail_bin_data_id, $chr_in);

  open(IN, "$filename") or die "Can't open $filename.";
  while (<IN>) {
    chop;
    my ( $chr,
         $bn,
         $chr,
         $s_pos,
         $e_pos,
         $n_value,
         $n_low_value,
         $n_high_value,
         $n,
         $avg,
         $low_avg,
         $high_avg ) = split "\t", $_;

    push @{ $binned_data_low_detail{$chr} }, join("\t",
            $bn,
            $chr,
            $s_pos,
            $e_pos,
            $n_low_value,
            $n,
            $low_avg
          );
    push @{ $binned_data_detail{$chr} }, join("\t",
            $bn,
            $chr,
            $s_pos,
            $e_pos,
            $n_value,
            $n,
            $avg
          );
    push @{ $binned_data_high_detail{$chr} }, join("\t",
            $bn,
            $chr,
            $s_pos,
            $e_pos,
            $n_high_value,
            $n,
            $high_avg
          );
  }
  close (IN);
}

######################################################################
sub Graph_detail {
  my ($chr, $pos, $start_pos_in, $end_pos_in, $CHOOSE_WAY,
      $detail_max, $detail_data_ref) = @_;

  my @graph_area = @{ $detail_data_ref };
  my $scalar = $DETAIL_SCALAR;

use GD;
 
  my $WIDTH = scalar(@graph_area) * $scalar;
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }

  my $high_scale = int($detail_max);
  my $GRAPH_HEIGHT        = 50 + $high_scale * $DETAIL_SCALE;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  $im->string(gdSmallFont, 0, $GRAPH_HEIGHT, 0, $COLORS{black});
  for (my $y0 = $GRAPH_HEIGHT - 50; $y0 >= 0; $y0 = $y0 - $DETAIL_SCALE) {
    my $x0 = 0;
    $im->string(gdSmallFont, $x0, $y0, int( 1 + ($GRAPH_HEIGHT - $y0)/$DETAIL_SCALE), $COLORS{black});
  }
 
  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
  my $total = @graph_area;

  for (my $i = 0; $i < @graph_area; $i++) {

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
                                               = split("\t", $graph_area[$i]);
    my $tmp_pos = $i * $scalar;
    if( ($i) % $SCALE == 0 ) {
      $i2value{$tmp_pos} = $start_pos;
    }
    if( $i == $total - 1 ) {
      if( not defined $i2value{$tmp_pos} ) {
        $i2value{$tmp_pos} = $start_pos;
      }
    }
    my $x0 = $PIX_PER_INTERVAL * ($i * $scalar) ;
    ## my $x1 = $PIX_PER_INTERVAL * ($i + $scalar);

    my $y0;
    if( $value <= 1 ) {
      $y0 = $GRAPH_HEIGHT - int(50 * $value);
    }
    else {
      $y0 = $GRAPH_HEIGHT - int(50 + ($value-1) * $DETAIL_SCALE);
    }
    my $y1;
    ## print "8888: $i, $value<br>";
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  ## my $x0 = $HALF_WIDTH + 30;
  ## my $x1 = $x0;
  ## ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  ## my $y0 = $mid_value;
  ## my $y1 = $GRAPH_HEIGHT;
  ## $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - int(50 * 1);
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});

  my $increase = ($pos_end - $pos_start) / 10;
  my $count = 0;
  ## $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }

  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  return $cache_id;
}

######################################################################
sub Graph_detail_high {

  my ($chr, $pos, $start_pos_in, $end_pos_in, $CHOOSE_WAY, 
      $max, $detail_data_ref) = @_;

  my @graph_area = @{ $detail_data_ref };
  my $scalar = $DETAIL_SCALAR;

use GD;
 
  my $WIDTH = scalar(@graph_area) * $scalar;
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }
  ## my $GRAPH_HEIGHT        = 50 + 100 * ( int($detail_max) + 2 );
  my $GRAPH_HEIGHT        = 200;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  my $x0 = $GRAPH_WIDTH+35;
  my $y0 = $GRAPH_HEIGHT - int(50 * ($max/($max + 1)) * 4);
  $im->string(gdSmallFont, $x0, $y0, $max, $COLORS{red});

  my $increase = (int($max) + 1)/10;
  my $count = 0;
  for (my $y0 = $GRAPH_HEIGHT; $y0 >= 0; $y0 = $y0 - 20) {
    my $value = $count*$increase;
    my $x0 = 0;
    $im->line ( $x0+25, $y0, $x0+30, $y0, $COLORS{red});
    $im->string(gdSmallFont, $x0, $y0, $value, $COLORS{red});
    $count++;
  }
 
  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
  my $total = @graph_area;

  for (my $i = 0; $i < @graph_area; $i++) {

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
                                               = split("\t", $graph_area[$i]);
    my $tmp_pos = $i * $scalar;
    if( ($i) % $SCALE == 0 ) {
      $i2value{$tmp_pos} = $start_pos;
    }
    if( $i == $total - 1 ) {
      if( not defined $i2value{$tmp_pos} ) {
        $i2value{$tmp_pos} = $start_pos; 
      }
    }
    my $x0 = $PIX_PER_INTERVAL * ($i * $scalar) ;
    ## my $x1 = $PIX_PER_INTERVAL * ($i + $scalar);
    my $y0;
    $y0 = $GRAPH_HEIGHT - int(50 * ($last_val/($max + 1)) * 4);
    my $y1;
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    ## if ($i == $current_pos) {
    ##   $mid_value = $y0;
    ## } 
    ## if( $x0 == $HIT_POSITION ) {
    ##   $mid_value = $y0;
    ## }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  ## my $x0 = $HALF_WIDTH + 30;
  ## my $x1 = $x0;
  ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  ## my $y0 = $mid_value;
  ## my $y1 = $GRAPH_HEIGHT;
  ## $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $y1;
  my $increase = ($total) / 10;
  my $count = 0;

  $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }

  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  return $cache_id;
}


######################################################################
sub Graph_chr {
  my ($org, $chr, $image_map_ref, $pos_in, $start_pos_in, $end_pos_in,
      $window_size, $filename, $mapped_cache_id, 
      $DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, $AMP_THRESHHOLD) = @_;

use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }
  my $GRAPH_HEIGHT        = 200;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * @{ $binned_data{$chr} };
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 30;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 200;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{blue}        = $im->colorAllocate(0,0,255);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);

  my $color;
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );
  for (my $y0 = $GRAPH_HEIGHT; $y0 >= 0; $y0 = $y0 - 50) {
    my $x0 = 0;
    $im->string(gdSmallFont, $x0, $y0, int(($GRAPH_HEIGHT - $y0)/50), $COLORS{black});
  }
 
  my $last_val;
  ## for (my $i = 1; $i < @{ $binned_data{$chr} } - 1; $i++ ) {
  for (my $i = 1; $i < @{ $binned_data{$chr} }; $i++ ) {
    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data{$chr}[$i]);
    my $x0 = $PIX_PER_INTERVAL * ($i - 1);
    my $x1 = $PIX_PER_INTERVAL * $i;
    my $y0 = $GRAPH_HEIGHT - int(50 * $last_val);
    my $y1;
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if( $start_pos >= $start_pos_in and $start_pos <= $end_pos_in  ) {
      $color = $COLORS{lightblue};
      $im->line (
          $x0+30,
          $y0,
          $x0+30,
          $y1,
          $color
      );
    } 
    else {
      $color = $COLORS{red};
      if ($x0 == $x1) {
        $im->line (
            $x0+30,
            $y0,
            $x1+30,
            $y1,
            $color
        );
      } else {
        $im->filledRectangle (
            $x0+30,
            $y0,
            $x1+30,
            $y1,
            $color
        );
      }
    }
    $last_val = $value;
    my $x0_pos = $x0+30;
    my $x1_pos = $x1+30;
    push @{ $image_map_ref },
      "<area shape=rect coords=\"$x0_pos,$y0,$x1_pos,$y1\" " .
      "href=javascript:spawn(\"DKViewDetail?ORG=$org&CHR=$chr&POS=$i&START_POS=&END_POS=&WINDOWSIZE=$window_size&FILENAME=$filename&MAPPED_DATA_CACHE_ID=$mapped_cache_id&DELWIDTH=$DEL_WIDTH&DELTHRESHHOLD=$DEL_THRESHHOLD&AMPWIDTH=$AMP_WIDTH&AMPTHRESHHOLD=$AMP_THRESHHOLD\")>";
  }
  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - int(50 * 1);
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});
  $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+10, "Chromosome " . $chr,
    $COLORS{black});
 
  ## print "8888: call WriteDKGEToCache <br>";
  return WriteDKToCache($im->png, $chr)
}

######################################################################
sub Graph_chr_high {
  my ($chr, $image_map_ref, $window_info_cache_id, $pos_in, 
      $window_size, $filename, $binned_data_id, $max, $mapped_cache_id) = @_;
 
use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }
  my $GRAPH_HEIGHT        = 50 * ( int($max) + 2 );
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * @{ $binned_data{$chr} };
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 30;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 200;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{blue}        = $im->colorAllocate(0,0,255);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);

  my $color;
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );
  for (my $y0 = $GRAPH_HEIGHT; $y0 >= 0; $y0 = $y0 - 50) {
    my $x0 = 0;
    $im->string(gdSmallFont, $x0, $y0, int(($GRAPH_HEIGHT - $y0)/50), $COLORS{black});
  }
 
  my $last_val;
  for (my $i = 1; $i < @{ $binned_data{$chr} } - 1; $i++ ) {
    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data{$chr}[$i]);
    my $x0 = $PIX_PER_INTERVAL * ($i - 1);
    my $x1 = $PIX_PER_INTERVAL * $i;
    my $y0 = $GRAPH_HEIGHT - int(50 * $last_val);
    my $y1;
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if( abs($i - $pos_in) <= 8 ) {
      if( ($i - $pos_in) == 0 ) {
        $color = $COLORS{lightblue};
      }
      else {
        $color = $COLORS{lightgray};
      }
      $im->line (
          $x0+30,
          $y0,
          $x0+30,
          $y1,
          $color
      );
    } 
    else {
      $color = $COLORS{red};
      if ($x0 == $x1) {
        $im->line (
            $x0+30,
            $y0,
            $x1+30,
            $y1,
            $color
        );
      } else {
        $im->filledRectangle (
            $x0+30,
            $y0,
            $x1+30,
            $y1,
            $color
        );
      }
    }
    $last_val = $value;
    my $x0_pos = $x0+30;
    my $x1_pos = $x1+30;
    push @{ $image_map_ref },
      "<area shape=rect coords=\"$x0_pos,$y0,$x1_pos,$y1\" " .
      "href=javascript:spawn(\"DKViewDetail?CHR=$chr&POS=$i&CACHE_ID=$window_info_cache_id&WINDOWSIZE=$window_size&FILENAME=$filename&BINNED_DATA_CACHE_ID=$binned_data_id&MAPPED_DATA_CACHE_ID=$mapped_cache_id\")>";
  }
  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - int(50 * 1);
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});
  $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+10, "Chromosome " . $chr,
    $COLORS{black});
 
  ## print "8888: call WriteDKGEToCache <br>";
  return WriteDKToCache($im->png, $chr)
}

######################################################################
sub Graph_detail_low {

  my ($chr, $pos, $start_pos_in, $end_pos_in, $CHOOSE_WAY,
      $max, $detail_data_ref) = @_;
 
  my @graph_area = @{ $detail_data_ref };
  my $scalar = $DETAIL_SCALAR;

use GD;
 
  my $WIDTH = scalar(@graph_area) * $scalar;
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }

  my $GRAPH_HEIGHT        = int(400 * $max) + 30;
  ## my $GRAPH_HEIGHT        = 400 + 50;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  $im->string(gdSmallFont, 0, $GRAPH_HEIGHT, 0, $COLORS{black});
  my $x = 0;
  my $y = $GRAPH_HEIGHT - int(400 * $max);
  $im->string(gdSmallFont, 0, $y, $max, $COLORS{black});
  $im->line ( $x+25, $y, $x+30, $y, $COLORS{black});

  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
  my $total = @graph_area;
 
  for (my $i = 0; $i < @graph_area; $i++) {
 
    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
                                               = split("\t", $graph_area[$i]);
    my $tmp_pos = $i * $scalar;
    if( ($i) % $SCALE == 0 ) {
      $i2value{$tmp_pos} = $start_pos;
    }
    if( $i == $total - 1 ) {
      if( not defined $i2value{$tmp_pos} ) {
        $i2value{$tmp_pos} = $start_pos;
      }
    }
    my $x0 = $PIX_PER_INTERVAL * ($i * $scalar) ;
    ## my $x0 = $PIX_PER_INTERVAL * ($tmp_i - 1);
    ## my $x1 = $PIX_PER_INTERVAL * $tmp_i;
    my $y0;
    $y0 = $GRAPH_HEIGHT - int(400 * $value);
    my $y1;
    ## print "8888: $i, $value<br>";
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    ## if ($i == $current_pos) {
    ##   $mid_value = $y0;
    ## } 
    ## if( $x0 == $HIT_POSITION ) {
    ##   $mid_value = $y0;
    ## }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  ## my $x0 = $HALF_WIDTH + 30;
  ## my $x1 = $x0;
  ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  ## my $y0 = $mid_value;
  ## my $y1 = $GRAPH_HEIGHT;
  ## $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - 400;
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});


  my $increase = ($pos_end - $pos_start) / 10;
  my $count = 0;

  $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }

  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  ########## need to fix
  return $cache_id;
}


######################################################################
sub Graph_chr_low {
  my ($chr, $image_map_ref, $window_info_cache_id, $pos_in, 
      $window_size, $filename, $binned_data_id, $max, $mapped_cache_id) = @_;
 
use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }
  my $GRAPH_HEIGHT        = 400 * (int($max) + 2);
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * @{ $binned_data{$chr} };
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 30;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 200;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{blue}        = $im->colorAllocate(0,0,255);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);

  my $color;
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );
  for (my $y0 = $GRAPH_HEIGHT; $y0 >= 0; $y0 = $y0 - 400) {
    my $x0 = 0;
    $im->string(gdSmallFont, $x0, $y0, int(($GRAPH_HEIGHT - $y0)/400), $COLORS{black});
  }
 
  my $last_val;
  for (my $i = 1; $i < @{ $binned_data{$chr} } - 1; $i++ ) {
    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data{$chr}[$i]);
    my $x0 = $PIX_PER_INTERVAL * ($i - 1);
    my $x1 = $PIX_PER_INTERVAL * $i;
    my $y0 = $GRAPH_HEIGHT - int(400 * $last_val);
    my $y1;
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(400 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if( abs($i - $pos_in) <= 8 ) {
      if( ($i - $pos_in) == 0 ) {
        $color = $COLORS{lightblue};
      }
      else {
        $color = $COLORS{lightgray};
      }
      $im->line (
          $x0+30,
          $y0,
          $x0+30,
          $y1,
          $color
      );
    } 
    else {
      $color = $COLORS{red};
      if ($x0 == $x1) {
        $im->line (
            $x0+30,
            $y0,
            $x1+30,
            $y1,
            $color
        );
      } else {
        $im->filledRectangle (
            $x0+30,
            $y0,
            $x1+30,
            $y1,
            $color
        );
      }
    }
    $last_val = $value;
    my $x0_pos = $x0+30;
    my $x1_pos = $x1+30;
    push @{ $image_map_ref },
      "<area shape=rect coords=\"$x0_pos,$y0,$x1_pos,$y1\" " .
      "href=javascript:spawn(\"DKViewDetail?CHR=$chr&POS=$i&CACHE_ID=$window_info_cache_id&WINDOWSIZE=$window_size&FILENAME=$filename&BINNED_DATA_CACHE_ID=$binned_data_id&MAPPED_DATA_CACHE_ID=$mapped_cache_id\")>";
  }
  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - int(400 * 1);
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});
  $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+10, "Chromosome " . $chr,
    $COLORS{black});
 
  ## print "8888: call WriteDKGEToCache <br>";
  return WriteDKToCache($im->png, $chr)
}
 

######################################################################
sub WriteDKDataToCache {
  my ($data) = @_;
 
  my ($dk_cache_id, $filename) = $dk_cache->MakeCacheFile();
  if ($dk_cache_id != $CACHE_FAIL) {
    ## print "8888 id: $dk_cache_id \n";
    ## print "8888 name: $filename \n";
    if (open(SOUT, ">$filename")) {
      print SOUT $data;
      close SOUT;
      chmod 0666, $filename;
    } else {
      $dk_cache_id = 0;
    }
  }
  return $dk_cache_id;
}
 
######################################################################
sub GetDKDataFromCache_1 {
  my ($base, $cache_id) = @_;
 
  $BASE = $base;
 
  return ReadDKDataFromCache($cache_id);
}
 
######################################################################
sub ReadDKDataFromCache {
  my ($cache_id) = @_;
 
  my ($s, @data);
  my $cache_pointer;
  if( $cache_id <10000 ) {
    $cache_pointer = $dk_cache;
  }
  else {
    $cache_pointer = $dk_query_cache;
  }
 
  if ($cache_pointer->FindCacheFile($cache_id) eq $CACHE_FAIL) {
    return "Cache expired";
  }
  my $filename = $cache_pointer->FindCacheFile($cache_id);
  ## print "$filename";
  open(IN, "$filename") or die "Can't open $filename.";
  ## while (read IN, $s, 16384) {
  ##   push @data, $s;
  ## }
  while (<IN>) {
    push @data, $_;
  }
  close (IN);
  return join("", @data);
 
}
 
######################################################################
sub WriteDKToCache {
  my ($data, $chr) = @_;
 
  my ($dk_cache_id, $filename) = $dk_cache->MakeDKCacheFile($chr);
  if ($dk_cache_id != $CACHE_FAIL) {
    ## print "8888 id: $dk_cache_id \n";
    ## print "8888 name: $filename \n";
    if (open(SOUT, ">$filename")) {
      print SOUT $data;
      close SOUT;
      chmod 0666, $filename;
    } else {
      $dk_cache_id = 0;
    }
  }
  return $dk_cache_id;
}
 
######################################################################
sub GetDKFromCache_1 {
  my ($base, $cache_id, $chr) = @_;
 
  $BASE = $base;
 
  return ReadDKFromCache($cache_id, $chr);
}
 
######################################################################
sub GetDKFromQueryCache_1 {
  my ($base, $cache_id, $chr) = @_;
 
  $BASE = $base;
 
  return ReadDKFromQueryCache($cache_id, $chr);
}
 
######################################################################
sub ReadDKFromCache {
  my ($cache_id, $chr) = @_;
 
  my ($s, @data);
 
  if ($dk_cache->FindDKCacheFile($cache_id, $chr) eq $CACHE_FAIL) {
    return "Cache expired";
  }
  my $filename = $dk_cache->FindDKCacheFile($cache_id, $chr);
  ## print "$filename";
  open(IN, "$filename") or die "Can't open $filename.";
  while (read IN, $s, 16384) {
    push @data, $s;
  }
  close (IN);
  return join("", @data);
 
}
 
######################################################################
sub ReadDKFromQueryCache {
  my ($cache_id, $chr) = @_;
 
  my ($s, @data);
 
  if ($dk_query_cache->FindDKCacheFile($cache_id, $chr) eq $CACHE_FAIL) {
    return "Cache expired";
  }
  my $filename = $dk_query_cache->FindDKCacheFile($cache_id, $chr);
  ## print "$filename";
  open(IN, "$filename") or die "Can't open $filename.";
  while (read IN, $s, 16384) {
    push @data, $s;
  }
  close (IN);
  return join("", @data);
 
}
 
######################################################################
sub Graph_high_detail {
  my ($chr, $pos, $CHOOSE_WAY, $detail_max) = @_;

use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }

  my $high_scale = int($detail_max);
  my $GRAPH_HEIGHT        = 50 + $high_scale * $DETAIL_SCALE;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  $im->string(gdSmallFont, 0, $GRAPH_HEIGHT, 0, $COLORS{black});
  for (my $y0 = $GRAPH_HEIGHT - 50; $y0 >= 0; $y0 = $y0 - $DETAIL_SCALE) {
    my $x0 = 0;
    $im->string(gdSmallFont, $x0, $y0, int( 1 + ($GRAPH_HEIGHT - $y0)/$DETAIL_SCALE), $COLORS{black});
  }
 
  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
 
  for (my $i = 1; $i < @{ $binned_data_high_detail{$chr} } - 1; $i++ ) {
    if( $i < $current_pos - $WIDTH/$CHOOSE_WAY or $i > $current_pos + $WIDTH/$CHOOSE_WAY ) {
      next;
    }

    if( not defined  $binned_data_high_detail{$chr}[$i] ) {
      next;
    }

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data_high_detail{$chr}[$i]);

    if( ($current_pos - $WIDTH/$CHOOSE_WAY <= 0) and ($i == 1) ) {
    
      $left_flag = 1;
    }
    elsif ( $i == $current_pos - $WIDTH/$CHOOSE_WAY ) {
      $pos_start = $start_pos;
    }

    my $len = @{ $binned_data_high_detail{$chr} } - 1;
    if( ($current_pos + $WIDTH/$CHOOSE_WAY >= $len) and ($i == $len - 1) ) {
      $pos_end = $start_pos;
      $right_flag = 1;
    } 
    elsif( $i == $current_pos + $WIDTH/$CHOOSE_WAY ) {
      $pos_end = $start_pos;
    }

    if( $current_pos == $i ) {
      $pos_click = $start_pos;
    }

    my $tmp_i = $i - ($current_pos - $WIDTH/$CHOOSE_WAY);

    if( ( $tmp_i % $SCALE ) == 0 ) {
      $i2value{$tmp_i} = $start_pos;
    }

    my $x0 = $PIX_PER_INTERVAL * ($tmp_i - 1);
    my $x1 = $PIX_PER_INTERVAL * $tmp_i;
    my $y0;
    if( $value <= 1 ) {
      $y0 = $GRAPH_HEIGHT - int(50 * $value);
    }
    else {
      $y0 = $GRAPH_HEIGHT - int(50 + ($value-1) * $DETAIL_SCALE);
    }
    my $y1;
    ## print "8888: $i, $value<br>";
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if ($i == $current_pos) {
      $mid_value = $y0;
    } 
    ## if( $x0 == $HIT_POSITION ) {
    ##   $mid_value = $y0;
    ## }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  my $x0 = $HALF_WIDTH + 30;
  my $x1 = $x0;
  ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  my $y0 = $mid_value;
  my $y1 = $GRAPH_HEIGHT;
  $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - int(50 * 1);
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});


  my $increase = ($pos_end - $pos_start) / 10;
  my $count = 0;
  if( $left_flag == 1 ) {
    my $x0 = $WIDTH/$CHOOSE_WAY - $current_pos;
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_start), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  elsif( $right_flag == 1 ) {
    my $x0 = $WIDTH - (($current_pos + $WIDTH/$CHOOSE_WAY) -  (@{ $binned_data_high_detail{$chr} } - 2));
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_end), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }
 
  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  return ($cache_id);
}

######################################################################
sub Graph_high_detail_high {
  my ($chr, $pos, $CHOOSE_WAY, $max) = @_;

use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }
  ## my $GRAPH_HEIGHT        = 50 + 100 * ( int($detail_max) + 2 );
  my $GRAPH_HEIGHT        = 200;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  my $x0 = $GRAPH_WIDTH+35;
  my $y0 = $GRAPH_HEIGHT - int(50 * ($max/($max + 1)) * 4);
  $im->string(gdSmallFont, $x0, $y0, $max, $COLORS{red});
 
  my $increase = (int($max) + 1)/10;
  my $count = 0;
  ## for (my $y0 = 0; $y0 <= $GRAPH_HEIGHT; $y0 = $y0 + 20) {
  for (my $y0 = $GRAPH_HEIGHT; $y0 >= 0; $y0 = $y0 - 20) {
    my $value = $count*$increase;
    my $x0 = 0;
    $im->line ( $x0+25, $y0, $x0+30, $y0, $COLORS{red});
    $im->string(gdSmallFont, $x0, $y0, $value, $COLORS{red});
    $count++;
  }

  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
 
  for (my $i = 1; $i < @{ $binned_data_high_detail{$chr} } - 1; $i++ ) {
    if( $i < $current_pos - $WIDTH/$CHOOSE_WAY or $i > $current_pos + $WIDTH/$CHOOSE_WAY ) {
      next;
    }

    if( not defined  $binned_data_high_detail{$chr}[$i] ) {
      next;
    }

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data_high_detail{$chr}[$i]);

    if( ($current_pos - $WIDTH/$CHOOSE_WAY <= 0) and ($i == 1) ) {
    
      $left_flag = 1;
    }
    elsif ( $i == $current_pos - $WIDTH/$CHOOSE_WAY ) {
      $pos_start = $start_pos;
    }

    my $len = @{ $binned_data_high_detail{$chr} } - 1;
    if( ($current_pos + $WIDTH/$CHOOSE_WAY >= $len) and ($i == $len - 1) ) {
      $pos_end = $start_pos;
      $right_flag = 1;
    } 
    elsif( $i == $current_pos + $WIDTH/$CHOOSE_WAY ) {
      $pos_end = $start_pos;
    }

    if( $current_pos == $i ) {
      $pos_click = $start_pos;
    }

    my $tmp_i = $i - ($current_pos - $WIDTH/$CHOOSE_WAY);

    if( ( $tmp_i % $SCALE ) == 0 ) {
      $i2value{$tmp_i} = $start_pos;
    }

    my $x0 = $PIX_PER_INTERVAL * ($tmp_i - 1);
    my $x1 = $PIX_PER_INTERVAL * $tmp_i;
    my $y0;
    $y0 = $GRAPH_HEIGHT - int(50 * ($last_val/($max + 1)) * 4);
    my $y1;
    ## print "8888: $i, $value<br>";
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if ($i == $current_pos) {
      $mid_value = $y0;
    } 
    ## if( $x0 == $HIT_POSITION ) {
    ##   $mid_value = $y0;
    ## }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  my $x0 = $HALF_WIDTH + 30;
  my $x1 = $x0;
  ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  my $y0 = $mid_value;
  my $y1 = $GRAPH_HEIGHT;
  $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $increase = ($pos_end - $pos_start) / 10;
  my $count = 0;
  if( $left_flag == 1 ) {
    my $x0 = $WIDTH/$CHOOSE_WAY - $current_pos;
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_start), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  elsif( $right_flag == 1 ) {
    my $x0 = $WIDTH - (($current_pos + $WIDTH/$CHOOSE_WAY) -  (@{ $binned_data_high_detail{$chr} } - 2));
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_end), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }

  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  return ($cache_id);
}

######################################################################
sub Graph_high_detail_low {
  my ($chr, $pos, $CHOOSE_WAY, $max) = @_;

use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }

  my $GRAPH_HEIGHT        = int(400 * $max) + 30;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  $im->string(gdSmallFont, 0, $GRAPH_HEIGHT, 0, $COLORS{black});
  my $x = 0;
  my $y = $GRAPH_HEIGHT - int(400 * $max);
  $im->string(gdSmallFont, 0, $y, $max, $COLORS{black});
  $im->line ( $x+25, $y, $x+30, $y, $COLORS{black});
 
  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
 
  for (my $i = 1; $i < @{ $binned_data_high_detail{$chr} } - 1; $i++ ) {
    if( $i < $current_pos - $WIDTH/$CHOOSE_WAY or $i > $current_pos + $WIDTH/$CHOOSE_WAY ) {
      next;
    }

    if( not defined  $binned_data_high_detail{$chr}[$i] ) {
      next;
    }

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data_high_detail{$chr}[$i]);

    if( ($current_pos - $WIDTH/$CHOOSE_WAY <= 0) and ($i == 1) ) {
    
      $left_flag = 1;
    }
    elsif ( $i == $current_pos - $WIDTH/$CHOOSE_WAY ) {
      $pos_start = $start_pos;
    }

    my $len = @{ $binned_data_high_detail{$chr} } - 1;
    if( ($current_pos + $WIDTH/$CHOOSE_WAY >= $len) and ($i == $len - 1) ) {
      $pos_end = $start_pos;
      $right_flag = 1;
    } 
    elsif( $i == $current_pos + $WIDTH/$CHOOSE_WAY ) {
      $pos_end = $start_pos;
    }

    if( $current_pos == $i ) {
      $pos_click = $start_pos;
    }

    my $tmp_i = $i - ($current_pos - $WIDTH/$CHOOSE_WAY);

    if( ( $tmp_i % $SCALE ) == 0 ) {
      $i2value{$tmp_i} = $start_pos;
    }

    my $x0 = $PIX_PER_INTERVAL * ($tmp_i - 1);
    my $x1 = $PIX_PER_INTERVAL * $tmp_i;
    my $y0;
    $y0 = $GRAPH_HEIGHT - int(400 * $value);
    my $y1;
    ## print "8888: $i, $value<br>";
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if ($i == $current_pos) {
      $mid_value = $y0;
    } 
    ## if( $x0 == $HIT_POSITION ) {
    ##   $mid_value = $y0;
    ## }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  my $x0 = $HALF_WIDTH + 30;
  my $x1 = $x0;
  ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  my $y0 = $mid_value;
  my $y1 = $GRAPH_HEIGHT;
  $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - 400;
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});


  my $increase = ($pos_end - $pos_start) / 10;
  my $count = 0;
  if( $left_flag == 1 ) {
    my $x0 = $WIDTH/$CHOOSE_WAY - $current_pos;
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_start), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  elsif( $right_flag == 1 ) {
    my $x0 = $WIDTH - (($current_pos + $WIDTH/$CHOOSE_WAY) -  (@{ $binned_data_high_detail{$chr} } - 2));
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_end), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }

  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  return ($cache_id);
}

######################################################################
sub Graph_low_detail {
  my ($chr, $pos, $CHOOSE_WAY, $detail_max) = @_;

use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }

  my $high_scale = int($detail_max);
  my $GRAPH_HEIGHT        = 50 + $high_scale * $DETAIL_SCALE;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  $im->string(gdSmallFont, 0, $GRAPH_HEIGHT, 0, $COLORS{black});
  for (my $y0 = $GRAPH_HEIGHT - 50; $y0 >= 0; $y0 = $y0 - $DETAIL_SCALE) {
    my $x0 = 0;
    $im->string(gdSmallFont, $x0, $y0, int( 1 + ($GRAPH_HEIGHT - $y0)/$DETAIL_SCALE), $COLORS{black});
  }
 
  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
 
  for (my $i = 1; $i < @{ $binned_data_low_detail{$chr} } - 1; $i++ ) {
    if( $i < $current_pos - $WIDTH/$CHOOSE_WAY or $i > $current_pos + $WIDTH/$CHOOSE_WAY ) {
      next;
    }

    if( not defined  $binned_data_low_detail{$chr}[$i] ) {
      next;
    }

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data_low_detail{$chr}[$i]);

    if( ($current_pos - $WIDTH/$CHOOSE_WAY <= 0) and ($i == 1) ) {
    
      $left_flag = 1;
    }
    elsif ( $i == $current_pos - $WIDTH/$CHOOSE_WAY ) {
      $pos_start = $start_pos;
    }

    my $len = @{ $binned_data_low_detail{$chr} } - 1;
    if( ($current_pos + $WIDTH/$CHOOSE_WAY >= $len) and ($i == $len - 1) ) {
      $pos_end = $start_pos;
      $right_flag = 1;
    } 
    elsif( $i == $current_pos + $WIDTH/$CHOOSE_WAY ) {
      $pos_end = $start_pos;
    }

    if( $current_pos == $i ) {
      $pos_click = $start_pos;
    }

    my $tmp_i = $i - ($current_pos - $WIDTH/$CHOOSE_WAY);

    if( ( $tmp_i % $SCALE ) == 0 ) {
      $i2value{$tmp_i} = $start_pos;
    }

    my $x0 = $PIX_PER_INTERVAL * ($tmp_i - 1);
    my $x1 = $PIX_PER_INTERVAL * $tmp_i;
    my $y0;
    if( $value <= 1 ) {
      $y0 = $GRAPH_HEIGHT - int(50 * $value);
    }
    else {
      $y0 = $GRAPH_HEIGHT - int(50 + ($value-1) * $DETAIL_SCALE);
    }
    my $y1;
    ## print "8888: $i, $value<br>";
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if ($i == $current_pos) {
      $mid_value = $y0;
    } 
    ## if( $x0 == $HIT_POSITION ) {
    ##   $mid_value = $y0;
    ## }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  my $x0 = $HALF_WIDTH + 30;
  my $x1 = $x0;
  ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  my $y0 = $mid_value;
  my $y1 = $GRAPH_HEIGHT;
  $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - int(50 * 1);
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});


  my $increase = ($pos_end - $pos_start) / 10;
  my $count = 0;
  if( $left_flag == 1 ) {
    my $x0 = $WIDTH/$CHOOSE_WAY - $current_pos;
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_start), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  elsif( $right_flag == 1 ) {
    my $x0 = $WIDTH - (($current_pos + $WIDTH/$CHOOSE_WAY) -  (@{ $binned_data_low_detail{$chr} } - 2));
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_end), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }

  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  return ($cache_id);
}

######################################################################
sub Graph_low_detail_high {
  my ($chr, $pos, $CHOOSE_WAY, $max) = @_;

use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }
  ## my $GRAPH_HEIGHT        = 50 + 100 * ( int($detail_max) + 2 );
  my $GRAPH_HEIGHT        = 200;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  my $x0 = $GRAPH_WIDTH+35;
  my $y0 = $GRAPH_HEIGHT - int(50 * ($max/($max + 1)) * 4);
  $im->string(gdSmallFont, $x0, $y0, $max, $COLORS{red});
 
  my $increase = (int($max) + 1)/10;
  my $count = 0;
  ## for (my $y0 = 0; $y0 <= $GRAPH_HEIGHT; $y0 = $y0 + 20) {
  for (my $y0 = $GRAPH_HEIGHT; $y0 >= 0; $y0 = $y0 - 20) {
    my $value = $count*$increase;
    my $x0 = 0;
    $im->line ( $x0+25, $y0, $x0+30, $y0, $COLORS{red});
    $im->string(gdSmallFont, $x0, $y0, $value, $COLORS{red});
    $count++;
  }

  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
 
  for (my $i = 1; $i < @{ $binned_data_low_detail{$chr} } - 1; $i++ ) {
    if( $i < $current_pos - $WIDTH/$CHOOSE_WAY or $i > $current_pos + $WIDTH/$CHOOSE_WAY ) {
      next;
    }

    if( not defined  $binned_data_low_detail{$chr}[$i] ) {
      next;
    }

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data_low_detail{$chr}[$i]);

    if( ($current_pos - $WIDTH/$CHOOSE_WAY <= 0) and ($i == 1) ) {
    
      $left_flag = 1;
    }
    elsif ( $i == $current_pos - $WIDTH/$CHOOSE_WAY ) {
      $pos_start = $start_pos;
    }

    my $len = @{ $binned_data_low_detail{$chr} } - 1;
    if( ($current_pos + $WIDTH/$CHOOSE_WAY >= $len) and ($i == $len - 1) ) {
      $pos_end = $start_pos;
      $right_flag = 1;
    } 
    elsif( $i == $current_pos + $WIDTH/$CHOOSE_WAY ) {
      $pos_end = $start_pos;
    }

    if( $current_pos == $i ) {
      $pos_click = $start_pos;
    }

    my $tmp_i = $i - ($current_pos - $WIDTH/$CHOOSE_WAY);

    if( ( $tmp_i % $SCALE ) == 0 ) {
      $i2value{$tmp_i} = $start_pos;
    }

    my $x0 = $PIX_PER_INTERVAL * ($tmp_i - 1);
    my $x1 = $PIX_PER_INTERVAL * $tmp_i;
    my $y0;
    $y0 = $GRAPH_HEIGHT - int(50 * ($last_val/($max + 1)) * 4);
    my $y1;
    ## print "8888: $i, $value<br>";
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if ($i == $current_pos) {
      $mid_value = $y0;
    } 
    ## if( $x0 == $HIT_POSITION ) {
    ##   $mid_value = $y0;
    ## }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  my $x0 = $HALF_WIDTH + 30;
  my $x1 = $x0;
  ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  my $y0 = $mid_value;
  my $y1 = $GRAPH_HEIGHT;
  $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $increase = ($pos_end - $pos_start) / 10;
  my $count = 0;
  if( $left_flag == 1 ) {
    my $x0 = $WIDTH/$CHOOSE_WAY - $current_pos;
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_start), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  elsif( $right_flag == 1 ) {
    my $x0 = $WIDTH - (($current_pos + $WIDTH/$CHOOSE_WAY) -  (@{ $binned_data_low_detail{$chr} } - 2));
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_end), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }

  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  return ($cache_id);
}

######################################################################
sub Graph_low_detail_low {
  my ($chr, $pos, $CHOOSE_WAY, $max) = @_;

use GD;
 
  my $STYLE               = "histogram"; # "line graph";    ## "histogram"
  my $PIX_PER_INTERVAL    = 1;
  if ($STYLE eq "line graph" && $PIX_PER_INTERVAL < 2) {
    die "for line graph, must have pixels per interval >= 2";
  }

  my $GRAPH_HEIGHT        = int(400 * $max) + 30;
  ## my $GRAPH_HEIGHT        = 400 + 50;
  my $GRAPH_WIDTH         = $PIX_PER_INTERVAL * $WIDTH; 
  my $IMAGE_HEIGHT        = $GRAPH_HEIGHT + 100;
  my $IMAGE_WIDTH         = $GRAPH_WIDTH  + 150;
  my $im = new GD::Image($IMAGE_WIDTH, $IMAGE_HEIGHT);
 
  # allocate some colors
##
## Apparently, the first color allocated becomes the background color of
## the image by default
##
 
  my %COLORS;
  $COLORS{white}       = $im->colorAllocate(255,255,255);
  $COLORS{black}       = $im->colorAllocate(0,0,0);
  $COLORS{lightgray}   = $im->colorAllocate(240,240,240);
  $COLORS{red}         = $im->colorAllocate(255,0,0);
  $COLORS{lightblue}   = $im->colorAllocate(0,255,255);
 
  $im->filledRectangle (
    0+30, 0, $GRAPH_WIDTH+30, $GRAPH_HEIGHT,
    $COLORS{black}
  );

  $im->string(gdSmallFont, 0, $GRAPH_HEIGHT, 0, $COLORS{black});
  my $x = 0;
  my $y = $GRAPH_HEIGHT - int(400 * $max);
  $im->string(gdSmallFont, 0, $y, $max, $COLORS{black});
  $im->line ( $x+25, $y, $x+30, $y, $COLORS{black});
 
  my $last_val;
  my ($pos_start, $pos_end, $pos_click);
  my ($left_flag, $right_flag);
  my $current_pos = ($pos-1)*BIN_SIZE/$CHOOSE_WAY;
  ## my $current_pos = $pos*BIN_SIZE/$CHOOSE_WAY;
  my $current_pos_start;
  my ($pre_x0, $pre_y0);
  my $mid_value;
  my %i2value;
 
  for (my $i = 1; $i < @{ $binned_data_low_detail{$chr} } - 1; $i++ ) {
    if( $i < $current_pos - $WIDTH/$CHOOSE_WAY or $i > $current_pos + $WIDTH/$CHOOSE_WAY ) {
      next;
    }

    if( not defined  $binned_data_low_detail{$chr}[$i] ) {
      next;
    }

    my ($bin_num, $chr, $start_pos, $end_pos, $start_tag, $end_tag, $value)
        = split("\t", $binned_data_low_detail{$chr}[$i]);

    if( ($current_pos - $WIDTH/$CHOOSE_WAY <= 0) and ($i == 1) ) {
    
      $left_flag = 1;
    }
    elsif ( $i == $current_pos - $WIDTH/$CHOOSE_WAY ) {
      $pos_start = $start_pos;
    }

    my $len = @{ $binned_data_low_detail{$chr} } - 1;
    if( ($current_pos + $WIDTH/$CHOOSE_WAY >= $len) and ($i == $len - 1) ) {
      $pos_end = $start_pos;
      $right_flag = 1;
    } 
    elsif( $i == $current_pos + $WIDTH/$CHOOSE_WAY ) {
      $pos_end = $start_pos;
    }

    if( $current_pos == $i ) {
      $pos_click = $start_pos;
    }

    my $tmp_i = $i - ($current_pos - $WIDTH/$CHOOSE_WAY);

    if( ( $tmp_i % $SCALE ) == 0 ) {
      $i2value{$tmp_i} = $start_pos;
    }

    my $x0 = $PIX_PER_INTERVAL * ($tmp_i - 1);
    my $x1 = $PIX_PER_INTERVAL * $tmp_i;
    my $y0;
    $y0 = $GRAPH_HEIGHT - int(400 * $value);
    my $y1;
    ## print "8888: $i, $value<br>";
    if ($STYLE eq "line graph") {
      $y1 = $GRAPH_HEIGHT - int(50 * $value);
    } else {
      $y1 = $GRAPH_HEIGHT;
    }
    if ($i == $current_pos) {
      $mid_value = $y0;
    }
    if (defined $pre_x0 and defined $pre_y0) {
      $im->line (
          $x0+30,
          $y0,
          $pre_x0,
          $pre_y0,
          $COLORS{red}
      );
    }
    $last_val = $value;
    $pre_x0 = $x0+30;
    $pre_y0 = $y0;
  }

  my $x0 = $HALF_WIDTH + 30;
  my $x1 = $x0;
  ## my $y0 = $GRAPH_HEIGHT - $mid_value;
  my $y0 = $mid_value;
  my $y1 = $GRAPH_HEIGHT;
  $im->line($x0, $y0, $x1, $y1, $COLORS{lightblue});

  my $x0 = 0 + 30;
  my $x1 = $GRAPH_WIDTH + 30;
  my $y0 = $GRAPH_HEIGHT - 400;
  my $y1 = $y0;
  $im->line($x0, $y0, $x1, $y1, $COLORS{white});


  my $increase = ($pos_end - $pos_start) / 10;
  my $count = 0;
  if( $left_flag == 1 ) {
    my $x0 = $WIDTH/$CHOOSE_WAY - $current_pos;
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_start), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  elsif( $right_flag == 1 ) {
    my $x0 = $WIDTH - (($current_pos + $WIDTH/$CHOOSE_WAY) -  (@{ $binned_data_low_detail{$chr} } - 2));
    $im->stringUp(gdSmallFont, $x0+20, $GRAPH_HEIGHT+80, int($pos_end), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($x0+30, $y0, $x0+30, $y1, $COLORS{black});
  }
  $im->string(gdSmallFont, 0+4, $GRAPH_HEIGHT+30, "bp:", $COLORS{black});

  for my $i (sort numerically keys %i2value) {
    $im->stringUp(gdSmallFont, $i+20, $GRAPH_HEIGHT+80, int($i2value{$i}), $COLORS{black});
    $y0 = $GRAPH_HEIGHT;
    $y1 = $y0 + 25;
    $im->line($i+30, $y0, $i+30, $y1, $COLORS{black});
  }

  ## $im->string(gdLargeFont, 0+30, $GRAPH_HEIGHT+70, "Chromosome " . $chr,
  ##   $COLORS{black});
 
  ## return (join "<br", @tmp);
  ## print "8888: call WriteDKGEToCache <br>";
  my $cache_id = WriteDKToCache($im->png, $chr);
  return ($cache_id);
}

######################################################################
sub Thousands {
  my ($x) = @_;
 
  my ($rem, $str);
  while ($x > 0) {
    $rem = sprintf("%3.3d", $x % 1000);
    $str = $str ? "$rem,$str" : "$rem";
    $x = int($x / 1000);
  }
  $str =~ s/^0+//;
  return $str;
}
 
######################################################################
sub DividerBar {
  my ($text) = @_;
 
  return "<table width=100% cellpadding=4>" .
      "<tr bgcolor=\"#666699\"><td><font color=\"white\"><b>" .
      $text .
      "</b></font></td></tr></table>";
}

######################################################################

sub Hunt_anomalies {
  my ($smoothed_cache_id, $DEL_WIDTH, $DEL_THRESHHOLD,
                          $AMP_WIDTH, $AMP_THRESHHOLD) = @_;
  
  ## input is 8 columns:
  ##   tag
  ##   chromosome
  ##   bp
  ##   strand
  ##   tag ordinal
  ##   raw freq
  ##   normalized freq
  ##   smoothed value
  
  my ($inp_f, $out_f);
  
  my $DEL_AREA = $DEL_WIDTH * $DEL_THRESHHOLD;
  my $AMP_AREA = $AMP_WIDTH * $AMP_THRESHHOLD;
  
  ReadData($smoothed_cache_id);
  
  Analyze($DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, $AMP_THRESHHOLD);
  
  for my $chr (@chr_order) {
    for my $start (sort numerically keys %{ $result{$chr} }) {
      for my $end (sort numerically keys %{ $result{$chr}{$start} }) {
        my $what = $result{$chr}{$start}{$end};
        ## my ($pos1, $pos2) = GetPosition($db, $chr, $start, $end);
        ## $pos1 = int(($pos1 + 500)/1000);
        ## $pos2 = int(($pos2 + 500)/1000);
        ## print "$chr\t$start\t$end\t$pos1\t$pos2\t$what\n";
        if( $what eq "amp" ) {
          $amp{$chr}{$start} = $end; 
        }
        elsif( $what eq "del" ) {
          $del{$chr}{$start} = $end;
        }
      }
    }
  }

}

######################################################################
sub AnalyzeChr {

  my ($chr, $v, $del_width, $del_threshhold, $amp_width, $amp_threshhold) = @_;

  ## version that does not take area; just look for continuous
  ## stretch of smoothed tags where each smoothed tag is > threshhold
 
  my ($start_del, $start_amp);
  my ($x);

  ## use zero base for arrays, adjust to tag number

  my $i;
  for ($i = 0; $i < @{ $v }; $i++) {
    $x = $$v[$i];

    if ($x <= $del_threshhold) {
      if (! $start_del) {
        $start_del = $i;
      }
    } else {
      if ($start_del) {
        if ($i-1 - $start_del >= $del_width) {
          $result{$chr}{$start_del+1}{$i} = "del";    ## adjust index
        }
      }
      $start_del = 0;
    }
    if ($x >= $amp_threshhold) {
      if (! $start_amp) {
        $start_amp = $i;
      }
    } else {
      if ($start_amp) {
        if ($i-1 - $start_amp >= $amp_width) {
          $result{$chr}{$start_amp+1}{$i} = "amp";    ## adjust index
        }
      }
      $start_amp = 0;
    }
  }
  if ($start_del && $i-1 - $start_del >= $del_width) {
    $result{$chr}{$start_del+1}{$i} = "del";    ## adjust index
  }
  if ($start_amp && $i-1 - $start_amp >= $amp_width) {
    $result{$chr}{$start_amp+1}{$i} = "amp";    ## adjust index
  }

}

######################################################################
sub Analyze {
  my ($DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, $AMP_THRESHHOLD) = @_;
  for my $chr (keys %data) {
    AnalyzeChr($chr, $data{$chr}, $DEL_WIDTH, $DEL_THRESHHOLD, $AMP_WIDTH, 
                                  $AMP_THRESHHOLD);
  }
}

######################################################################
sub ReadData {
  my ($smoothed_cache_id) = @_;
  my (%freq, %chr_2_id);
 
  my @tmp = split ",", $smoothed_cache_id;
  for (my $i=0; $i<@tmp; $i++) {
    my ($chr, $id) = split "_", $tmp[$i];
    $chr_2_id{$chr} = $id;
  }
 
  my ($chromo, $start_pos, $end_pos);
  my $need_tag_num = 1;
  get_data_from_dkmap($chromo, $start_pos, $end_pos, $need_tag_num);
 
  for my $chr (@chr_order) {
    if ($dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr) eq $CACHE_FAIL) {
      return "Cache expired";
    }
    my $filename = $dk_cache->FindDKCacheFile($chr_2_id{$chr}, $chr);
    open(IN, "$filename") or die "Can't open $filename.";
    my $count = 0;  ## index not ord
    while (<IN>) {
      chop;
      my ($tag, $chr, $bp, $strand, $ord) = split /\t/, $dkmap{$chr}[$count];
      $data{$chr}[$ord] = $_;
      $ord2bp{$chr}{$ord} = $bp;
      ## $ord2num{$chr}{$ord} = $ord;
      $count++;
    }
    close (IN);
  }
}

######################################################################
sub amp_area {
  my ($chr, $start_tag, $end_tag) = @_;
  for my $start (sort numerically keys %{$amp{$chr}}) {
    if( $start_tag >= $start ) {
      if( $end_tag <= $amp{$chr}{$start} ) {
      ## if( $start_tag <= $amp{$chr}{$start} ) {
        return 1;
      }
    }
  }
  return "";
}

######################################################################
sub del_area {
  my ($chr, $start_tag, $end_tag) = @_;
  for my $start (sort numerically keys %{$del{$chr}}) {
    if( $start_tag >= $start ) {
      if( $end_tag <= $del{$chr}{$start} ) {
      ## if( $start_tag <= $del{$chr}{$start} ) {
        return 1;
      }
    }
  }
  return "";
}

######################################################################
sub get_data_from_dkmap {
  my ($chr, $start_pos, $end_pos, $need_tag_num) = @_;

  my ($db, $sql, $stm);
  $db = DBI->connect("DBI:Oracle:" . DB_INSTANCE, DB_USER, DB_PASS);
  if (not $db or $db->err()) {
    print "Cannot connect to " . DB_USER . "@" . DB_INSTANCE . "\n";
    exit();
  }
 
  if( $chr eq "" ) {
    $sql = "select TAG, CHROMOSOME, POS, STRAND, TAGNUM " .
           "from $CGAP_SCHEMA.DKMAP order by CHROMOSOME, TAGNUM";
  }
  elsif( $start_pos eq "" ) {
    $sql = "select TAG, CHROMOSOME, POS, STRAND, TAGNUM " .
           "from $CGAP_SCHEMA.DKMAP where CHROMOSOME = '$chr' " .
           "order by TAGNUM";
  }
  else {
    $sql = "select TAG, CHROMOSOME, POS, STRAND, TAGNUM " .
           "from $CGAP_SCHEMA.DKMAP where CHROMOSOME = '$chr' " .
           "and POS >= $start_pos and POS <= $end_pos oorder by TAGNUM";
  }
  
  $stm = $db->prepare($sql);
  if(not $stm) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "prepare call failed\n";
  }
  if(!$stm->execute()) {
    print STDERR "$sql\n";
    print STDERR "$DBI::errstr\n";
    print STDERR "execute call failed\n";
  }
  while(my ($tag, $chr, $pos, $strand, $tag_num) = $stm->fetchrow_array()) {
    if( $need_tag_num == 1 ) {
      push @{ $dkmap{$chr} }, join ("\t", $tag, $chr, $pos, $strand, $tag_num);
    }
    else {
      push @{ $dkmap{$chr} }, join ("\t", $tag, $chr, $pos, $strand);
    }
  }
 
  $db->disconnect();
}

######################################################################
sub Make_Display_amp_del_page {   
  my ($org, $smoothed_cache_id, $bin_size, $window_size,
      $mapped_cache_id, $DEL_WIDTH, $DEL_THRESHHOLD,
      $AMP_WIDTH, $AMP_THRESHHOLD, $filename) = @_; 

  my $output = 
       "<br><a href=javascript:spawn(\"/SAGE/DKView_All?ORG=Hs&MAPPED_DATA_CACHE_ID=$mapped_cache_id&SMOOTHED_CACHE_ID=$smoothed_cache_id&WINDOWSIZE=$window_size&FILENAME=$filename&DELWIDTH=$DEL_WIDTH&DELTHRESHHOLD=$DEL_THRESHHOLD&AMPWIDTH=$AMP_WIDTH&AMPTHRESHHOLD=$AMP_THRESHHOLD\")>Display all chromosome DKView</a><br><br>";
        
  $output = $output .
    "<b>Amplification Info:<b><br>" .
    "<table border=\"1\" width=100% cellpadding=2>" .
    "<tr bgcolor=\"#666699\">" .
    "<td width=9%><font color=\"white\"><b>Chromosome</b></font></td>" .
    "<td width=18%><font color=\"white\"><b>Start Number</b></font></td>" .
    "<td width=14%><font color=\"white\"><b>Start Position</b></font></td>" .
    "<td width=18%><font color=\"white\"><b>End Number</b></font></td>" .
    "<td width=14%><font color=\"white\"><b>End Position</b></font></td>" .
    "<td width=9%><font color=\"white\"><b>Detail DKView</b></font></td>" .
    "<td width=9%><font color=\"white\"><b>UCSC</b></font></td>" .
    "<td width=9%><font color=\"white\"><b>Download</b></font></td>" .
    "</tr>";

  my $sign = "UCSC";
  for my $chr (@chr_order) {
    my $chr_for_url = "chr" . $chr;
    for my $start_amp ( sort numerically keys %{$amp{$chr}} ) {
      my @lines;
      my $start_pos = $ord2bp{$chr}{$start_amp};
      my $end_pos = $ord2bp{$chr}{$amp{$chr}{$start_amp}};
      push @lines, "<tr>";
      push @lines, "<td width=9%>$chr</td>";
      push @lines, "<td width=18%>$start_amp</td>"; 
      push @lines, "<td width=14%>$start_pos</td>"; 
      push @lines, "<td width=18%>$amp{$chr}{$start_amp}</td>"; 
      push @lines, "<td width=14%>$end_pos</td>"; 
      my $view_highperlink = "<a href=javascript:spawn(\"" .
        "DKViewDetail?ORG=$org&CHR=$chr&POS=&START_POS=$start_pos" .
        "&END_POS=$end_pos&WINDOWSIZE=$window_size&" .
        "FILENAME=$filename&MAPPED_DATA_CACHE_ID=$mapped_cache_id&DELWIDTH=$DEL_WIDTH&DELTHRESHHOLD=$DEL_THRESHHOLD&AMPWIDTH=$AMP_WIDTH&AMPTHRESHHOLD=$AMP_THRESHHOLD\")>View</a>"; 
      push @lines, "<td width=9%>$view_highperlink</td>"; 
      my $highperlink = "<a href=javascript:spawn(\"" .
        "http://genome.ucsc.edu/cgi-bin/hgTracks?clade=vertebrate" .
        "&org=$org&db=$UCSC_DB&position=$chr_for_url:$start_pos-$end_pos" .
        "&pix=620\")>$sign</a>";
      push @lines, "<td width=9%>$highperlink</td>"; 
      my $download_highperlink =
        "<a href=javascript:spawn(\"/SAGE/DKRegionDownload?ORG=Hs&CHR=$chr&MAPPED_DATA_CACHE_ID=$mapped_cache_id&START_POS=$start_pos&END_POS=$end_pos&FILENAME=$filename\")>Download</a>";
      push @lines, "<td width=9%>$download_highperlink</td>"; 
      push @lines, "</tr>";
      $output = $output . (join "", @lines) . "\n";
    }
  }

   
  $output = $output . "</table><br><br><br>";

  $output = $output .
    "<b>Deletion Info:<b><br>" .
    "<table border=\"1\" width=100% cellpadding=2>" .
    "<tr bgcolor=\"#666699\">" .
    "<td width=9%><font color=\"white\"><b>Chromosome</b></font></td>" .
    "<td width=18%><font color=\"white\"><b>Start Number</b></font></td>" .
    "<td width=14%><font color=\"white\"><b>Start Position</b></font></td>" .
    "<td width=18%><font color=\"white\"><b>End Number</b></font></td>" .
    "<td width=14%><font color=\"white\"><b>End Position</b></font></td>" .
    "<td width=9%><font color=\"white\"><b>Detail DKView</b></font></td>" .
    "<td width=9%><font color=\"white\"><b>UCSC</b></font></td>" .
    "<td width=9%><font color=\"white\"><b>Download</b></font></td>" .
    "</tr>";
   
  for my $chr (@chr_order) {
    my $chr_for_url = "chr" . $chr;
    for my $start_del ( sort numerically keys %{$del{$chr}} ) {
      my @lines;
      my $start_pos = $ord2bp{$chr}{$start_del};
      my $end_pos = $ord2bp{$chr}{$del{$chr}{$start_del}};
      push @lines, "<tr>";
      push @lines, "<td width=9%>$chr</td>";
      push @lines, "<td width=18%>$start_del</td>"; 
      push @lines, "<td width=14%>$start_pos</td>"; 
      push @lines, "<td width=18%>$del{$chr}{$start_del}</td>"; 
      push @lines, "<td width=14%>$end_pos</td>"; 
      my $view_highperlink = "<a href=javascript:spawn(\"" .
        "DKViewDetail?ORG=$org&CHR=$chr&POS=&START_POS=$start_pos" .
        "&END_POS=$end_pos&WINDOWSIZE=$window_size&" .
        "FILENAME=$filename&MAPPED_DATA_CACHE_ID=$mapped_cache_id&DELWIDTH=$DEL_WIDTH&DELTHRESHHOLD=$DEL_THRESHHOLD&AMPWIDTH=$AMP_WIDTH&AMPTHRESHHOLD=$AMP_THRESHHOLD\")>View</a>"; 
      push @lines, "<td width=9%>$view_highperlink</td>"; 
      my $highperlink = "<p><a href=javascript:spawn(\"" .
          "http://genome.ucsc.edu/cgi-bin/hgTracks?clade=vertebrate" .
          "&org=$org&db=$UCSC_DB&position=$chr_for_url:$start_pos-$end_pos" .
          "&pix=620\")>$sign</a>";
      push @lines, "<td width=9%>$highperlink</td>"; 
      my $download_highperlink =
        "<p><a href=javascript:spawn(\"/SAGE/DKRegionDownload?ORG=Hs&CHR=$chr&MAPPED_DATA_CACHE_ID=$mapped_cache_id&START_POS=$start_pos&END_POS=$end_pos&FILENAME=$filename\")>Download</a>";
      push @lines, "<td width=9%>$download_highperlink</td>"; 
      push @lines, "</tr>";
      $output = $output . (join "", @lines) . "\n";
    }
  }

   
  $output = $output . "</table>";

  return $output;

}

######################################################################
sub Make_detail_html {   
  
  my ($org, $chr_in, $pos_in, $start_pos_in, $end_pos_in, $window_size,
      $filename, $mapped_data_cache_id, $DEL_WIDTH, $DEL_THRESHHOLD,  
                                     $AMP_WIDTH, $AMP_THRESHHOLD) = @_;
  my $lines;
  my $sign = "UCSC browser.";
  my $chr_for_url = "chr" . $chr_in;
  my $highperlink = "<p><a href=javascript:spawn(\"" .
          "http://genome.ucsc.edu/cgi-bin/hgTracks?clade=vertebrate" .
          "&org=$ORGANISM_NAME{$org}&db=$UCSC_DB" .
          "&position=$chr_for_url:$start_pos_in-$end_pos_in" .
          "&pix=620\")>$sign</a><br><br>";

  $lines = $highperlink;

  my $download_highperlink =
      "<p><a href=javascript:spawn(\"/SAGE/DKRegionDownload?ORG=Hs&CHR=$chr_in&MAPPED_DATA_CACHE_ID=$mapped_data_cache_id&START_POS=$start_pos_in&END_POS=$end_pos_in&FILENAME=$filename\")>Down load region mapped data</a><br><br>";

  $lines = $lines . $download_highperlink;

  my $file_name;
  ## push @lines, "File name: $filename<br>";
  my $window_size_for_html = "Window size: $window_size <br>";
  $lines = $lines . $window_size_for_html;
  $lines = $lines . "Amplification width: $AMP_WIDTH<br>";
  $lines = $lines . "Amplification change: $AMP_THRESHHOLD<br>";
  $lines = $lines . "Delesion width: $DEL_WIDTH<br>";
  $lines = $lines . "Delesion change: $DEL_THRESHHOLD<br>";

  $lines = $lines .
    "<form name=\"dkform\" action=\"DKViewDetail\") method=post target=_blank>\n" .
    "<input type=\"hidden\" name=\"MAPPED_DATA_CACHE_ID\" value=$mapped_data_cache_id>\n" .
    "<input type=\"hidden\" name=\"FILENAME\" value=$file_name>\n" .
    "<input type=\"hidden\" name=\"ORG\" value=$org>\n" .
    "<input type=\"hidden\" name=\"CHR\" value=$chr_in>\n" .
    "<input type=\"hidden\" name=\"DELWIDTH\" value=$DEL_WIDTH>\n" .
    "<input type=\"hidden\" name=\"DELTHRESHHOLD\" value=$DEL_THRESHHOLD>\n" .
    "<input type=\"hidden\" name=\"AMPWIDTH\" value=$AMP_WIDTH>\n" .
    "<input type=\"hidden\" name=\"AMPTHRESHHOLD\" value=$AMP_THRESHHOLD>\n" .
    "<table border=\"0\" width=90% cellpadding=2>\n" .
    "<tr><td>&nbsp;\n" .
    "</td>\n" .
    "<td>&nbsp;\n" .
    "</td></tr>\n" .
    "<tr>" .
    "<td colspan=2 bgcolor=\"336699\" align=center><font color=\"FFFFFF\">\n" .
    "<B>Enter window data for re-window</B>\n" .
    "</font></td></tr><br>\n" .
        "<tr><td>&nbsp;\n" .
    "</td>\n" .
    "<td>&nbsp;\n" .
    "</td></tr>\n" .
    "<tr>\n" .
    "  <td align=left width=45%>1. Enter the window size.</td>\n" .
    "  <td align=left>\n" .
    "  <input type=text name=\"WINDOWSIZE\" value=\"$window_size\" size=30>\n" .
    "  </td>\n" .
    "</tr>\n" .
    "<tr>\n" .
    "  <td align=left width=45%>2. Enter the window start.</td>\n" .
    "  <td align=left>\n" .
    "  <input type=text name=\"START_POS\" value=\"$start_pos_in\" size=30>\n" .
    "  </td>\n" .
    "</tr>\n" .
    "<tr>\n" .
    "<tr>\n" .
    "  <td align=left width=45%>3. Enter the window end.</td>\n" .
    "  <td align=left>\n" .
    "  <input type=text name=\"END_POS\" value=\"$end_pos_in\" size=30>\n" .
    "  </td>\n" .
    "</tr>\n" .
    "<tr>\n" .
    "<td>4. Submit query:</td>\n" .
    "<td> " .
    "<input type=submit value=\"Submit Query\">" .
    "</td>\n" .
    "</tr>\n" .
    "<tr><td>&nbsp;\n" .
    "</td>\n" .
    "<td>&nbsp;\n" .
    "</td></tr>\n" .
    "<tr>" .
    "<td colspan=2 bgcolor=\"336699\" align=center><font color=\"FFFFFF\">\n" .
    "<B>Detail DKView:</B>\n" .
    "</font></td></tr><br>\n" .
        "<tr><td>&nbsp;\n" .
    "</td>\n" .
    "<td>&nbsp;\n" .
    "</td></tr>\n" .
    "<tr>\n" .
    "</table>\n" .
    "</blockquote>\n" .
    "</form>\n";
 
  return $lines;  
}

######################################################################
sub numerically { $a <=> $b; }
 
######################################################################
1;
